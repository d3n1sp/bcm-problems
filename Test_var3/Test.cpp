// Test.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"
#define ___MPI_INIT___ 
#define ___nIGROUPS_NGROUPS___
#ifdef  ___MPI_INIT___
#include "mpi.h"
#include "ExchangeMPI.h"
#include "gsmatrix.h"
#endif
#include "ccebasic.h"
#include "cgrid_qg.h"
#include "ccohes3d.h"
#include "csmixer.h"
#include "csolver.h"
#include "clame2d.h"
#include "clame3d.h"
#include "cheat2d.h"
#include "cheat3d.h"
#include "dd_real.h"
#include "nurbs.h"
#define n_MUNI_APPROXIMATION
#define n_INP_CONVERTOR
//----------------------------------------------------------------------------------------
void Inp_nodes_add	(char * ch_NODES, CGrid * nd, int   ID_node_set, int ID_element_set);
void Inp_elements_add(char * ch_NODES, CGrid * nd, int * ID_elements, int ID_element_set);
//----------------------------------------------------------------------------------------
#define n_UWay_CONVERTOR
//----------------------------------------------------------------------------------------
void Convert3D_gmt(char * ch_NODES, CGrid * nd, int ID_part);
void Convert3D_prb(char * ch_NODES, CGrid * nd, int ID_part);
//----------------------------------------------------------------------------------------
#define n_C3D_CONVERTOR
//----------------------------------------------------------------------------------------
void Read_C3D_Header(unsigned short *num_markers, unsigned short *num_channels, unsigned short *first_field, unsigned short *last_field,
							float *scale_factor,	unsigned short *start_record_num, unsigned short *frames_per_field, float *video_rate,	FILE *infile);
void Read_C3D_Parameters(unsigned char	**mlabels, unsigned char **alabels,	float *gscale,	float *ascale,	int *zero_off,	FILE *infile);
void Read_C3D_Channel(unsigned short channel_num, unsigned short num_markers,	unsigned short num_analog_channels,	unsigned short first_field,
							 unsigned short last_field, unsigned short start_byte, unsigned short analog_frames_per_field, short *val, FILE *infile);

void Read_C3D_Marker(unsigned short marker_num,	unsigned short num_markers, unsigned short num_analog_channels, unsigned short first_field, unsigned short last_field,
							unsigned short	start_byte,	unsigned short analog_frames_per_field, short **val, unsigned char *res, FILE	*infile);
void Read_C3D_Data_int(unsigned short num_markers, unsigned short num_analog_channels, unsigned short first_field, unsigned short last_field, unsigned short start_byte, unsigned short analog_frames_per_field,
							  short **x, short **y, short **z, char **residual, char **num_cam, short **analog, FILE *infile);
void Read_C3D_Data_float(unsigned short num_markers, unsigned short num_analog_channels, unsigned short first_field, unsigned short last_field, unsigned short start_byte, unsigned short analog_frames_per_field,
								 float **x, float **y, float **z, char **residual, char **num_cam, short **analog, FILE *infile);
//----------------------------------------------------------------------------------------
#define n_TEST_CCELLS
#define n_TEST_SHAPES
#define TEST_DRAFT_ALL
#define n_TEST_DRAFT_VISCO
#define n_TEST_DRAFT_HYDRO
#define n_TEST_DRAFT_VIBRO
//----------------------------------------------------------------------------------------
template <typename T> 
void Number_of_Blocks	(void * _pBCM, int & _NBlks);
template <typename T> 
void Blocks_Partitioning(void * _pBCM, int * _Blks);
template <typename T> 
void Blocks_Sparsity		(void * _pBCM, int *& _IA, int *& _JA);
template <typename T> 
void Blocks_Row			(void * _pBCM, int _BlkRow, double * _defc);
template <typename T> 
void Right_Handside		(void * _pBCM, int _BlkRow, double * _refc);
template <typename T> 
void Initial_Guess		(void * _pBCM, int _BlkRow, double * _refc);
template <typename T> 
void Store_Solution		(void * _pBCM, int _BlkRow, double * _refc);
template <typename T> 
void Blocks_SparsitySym	(void * _pBCM, int *& _IA, int *& _JA);
template <typename T> 
void Blocks_RowSym		(void * _pBCM, int _BlkRow, double * _defc);
template <typename T> 
//----------------------------------------------------------------------------------------
#define n_LAME3D_LAYERED_ESHELBY_HOMOGENIZATION
#define n_CHYDRO3D_ANALYT_HOMOGENIZATION
#define n_TEST_DRAFT_LAME3D_INTERMEDIATE_PHASE
#define n_TEST_DRAFT_LAME2D_FROM_FEMAP
#define n_TEST_DRAFT_COHES2D_FROM_FEMAP
#define n_TEST_CCOHES2D_CONSTRUCTION_FROM_FEMAP
//----------------------------------------------------------------------------------------
double CIdent(char * name_ini, double R, double A, double * energy, double l1, double l2, double G1, double G2, double nju1, double nju2, 
										 double Ad = 0, double Bd = 0, int N0 = 5, int id_layer = NULL_STATE, int id_direct = NULL_STATE, int id_visual = NULL_STATE);
double CIdent_sphere3D(double * energy, double rad, double fV, double l1, double l2, 
							  double G1, double G2, double nju1, double nju2, int N0 = 3, int id_visual = 0);
//----------------------------------------------------------------------------------------
#define n_TEST_DRAFT_GRADIENT2D_FROM_FEMAP
#define n_TEST_DRAFT_LAME3D_SPHEROID
//----------------------------------------------------------------------------------------
double TakeLayer_EH   (int N, double * ff, double * kk, double * ll);
double TakeCylinder_EH(int N, double * ff, double * kk);
double TakeCylinder_KH(int N, double * ff, double * kp, double * mu);
double TakeCylinder_GH(int N, double * ff, double * kp, double * mu, double * nj);
double TakeCylinder_SH(int N, double * ff, double * kp, double * mu, double * nj);
double TakeCylinder_LH(int N, double * ff, double * lm, double * mu, double * nj);
double TakeCylinder_GH(int N, double * ff, double * mu, double * nj);
double TakeSphere_KH	 (int N, double * ff, double * kv, double * mu);
double TakeSphere_GH	 (int N, double * ff, double * kv, double * mu, double * nj);
double TakeSphere_GH_det	(double c0, double nju1, double nju2, double E1, double E2);
double TakeSphere_volm_two (double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
double TakeSphere_volm_sym (double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
double TakeSphere_shear_two(double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
double TakeSphere_shear		(double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
double TakeSphere_shear_sym(double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
//----------------------------------------------------------------------------------------
#define n_DRAFT_LAME_ESHELBY_NONLINEAR_DIAGRAM
#define n_DRAFT_LAME_ESHELBY_COMPARISON_DIAGRAM
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_sph
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_cyl
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_layer
#define n_TEST_DRAFT_LAME_ESHELBY
#define n_ESHELBY_CALCULATIONS
#define n_ALUMO_COMPOSITES_CALCULATIONS
#define n_ALUMO_COMPOSITES_EXAMPLES
#define n_MINDL2D_CALCULATIONS
#define n_TEST_DRAFT_HEAT_ESHELBY
#define n_TEST_DRAFT_HEAT_NONLINEAR_LAYER
#define n_TEST_DRAFT_HEAT_FIRST_MEMBER
#define n_TEST_DRAFT_HEAT_FIRST_MEMBER_NONLINEAR_LAYER
//----------------------------------------------------------------------------------------
#ifdef ___MPI_INIT___
CMPIComm comm_mpi;
#endif
#define Message(Msg)   { printf("%s", Msg);  printf("\n");}

int main(int argc, char* argv[])
{
#ifdef ___IGROUPS_NGROUPS___
	int igroup = 1, ngroups = 1;
#endif
#ifdef ___MPI_INIT___
	int myidgl, numprocsgl;
	int namelen;
	char processor_name[MPI_MAX_PROCESSOR_NAME];

	MPI_Init (&argc,&argv);

	MPI_Comm_size (MPI_COMM_WORLD,&numprocsgl);
	MPI_Comm_rank (MPI_COMM_WORLD,&myidgl);
	MPI_Get_processor_name (processor_name,&namelen);

	std::cout << " Myid = " << myidgl << " Processor name = " << processor_name << std::endl;

	MPI_Comm commloc = MPI_COMM_WORLD;
#ifdef ___IGROUPS_NGROUPS___
	comm_mpi = CMPIExchange::GetCommMPI(ngroups,igroup);
#else
	comm_mpi.SetCommMPI (&commloc);
#endif
#endif
#ifdef ___IGROUPS_NGROUPS___
	if (igroup == 0) {
#endif
	time_t start = time(NULL), sec;
	char buf[2000]; int res;

#ifdef MUNI_APPROXIMATION
{
/////////////////////
//...\E8\F1\F5\EE\E4\ED\FB\E5 \E4\E0\ED\ED\FB\E5;
	//int  N_muni = 269;
	//double muni[][2] = {//...\ED\E5\ED\E0\EF\EE\EB\ED\E5\ED\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
	//{1.,0.00173},		{1.00072,0.00496},{1.01092,0.03958},{1.02204,0.05216},{1.03496,0.04343},{1.04408,0.07734},{1.05296,0.11117},{1.06612,0.12612},{1.07748,0.08906},{1.08696,0.12368},
	//{1.09688,0.15602},{1.10596,0.18592},{1.11556,0.16381},{1.1266, 0.17325},{1.13592,0.19371},{1.14536,0.20315},{1.15568,0.21574},{1.16528,0.22203},{1.1766, 0.22998},{1.18588,0.22596},
	//{1.19436,0.25830},{1.20468,0.28104},{1.21412,0.26932},{1.22296,0.28655},{1.23188,0.29528},{1.241,  0.28733},{1.2502, 0.31731},{1.2606, 0.33462},{1.26884,0.31408},{1.279,  0.33304},
	//{1.28852,0.34083},{1.29784,0.34799},{1.3102, 0.35500},{1.3218, 0.36688},{1.33228,0.37545},{1.34224,0.38332},{1.35488,0.38961},{1.366,  0.40535},{1.37648,0.39363},{1.385,  0.39599},
	//{1.39616,0.41951},{1.40452,0.42895},{1.41424,0.41873},{1.4244, 0.44469},{1.43356,0.42974},{1.44388,0.44312},{1.45696,0.44862},{1.4692, 0.47301},{1.47788,0.46050},{1.4894, 0.50134},
	//{1.50288,0.48489},{1.51124,0.50063},{1.5256, 0.48096},{1.53364,0.49898},{1.54292,0.51786},{1.555,	0.52809},{1.5742,	0.53367},{1.585,	0.52258},{1.59592,0.52337},{1.60504,0.54540},
	//{1.61376,0.53517},{1.62232,0.55885},{1.63116,0.55334},{1.64044,0.55484},{1.6498,	0.56743},{1.65972,0.56908},{1.67044,0.58159},{1.68124,0.57852},{1.6942,	0.57766},{1.70532,0.56908},
	//{1.71552,0.59575},{1.72372,0.60126},{1.7364,	0.60842},{1.75056,0.59182},{1.7604,	0.61070},{1.77024,0.61935},{1.78152,0.63438},{1.79052,0.62258},{1.8016,	0.63438},{1.81344,0.62644},
	//{1.82436,0.63281},{1.83304,0.63981},{1.84356,0.64847},{1.85452,0.64532},{1.86764,0.65799},{1.88208,0.63666},{1.8912,	0.65948},{1.90088,0.67215},{1.9112,	0.68159},{1.92544,0.68308},
	//{1.94012,0.66900},{1.95044,0.68238},{1.95928,0.69567},{1.96812,0.69803},{1.98148,0.68072},{1.99592,0.69339},{2.008,	0.68238},{2.01888,0.69410},{2.02984,0.70205},{2.03876,0.72400},
	//{2.04868,0.71070},{2.059,	0.72172},{2.06964,0.72242},{2.08008,0.72006},{2.08988,0.72950},{2.10092,0.72950},{2.11156,0.73588},{2.12252,0.72478},{2.13588,0.74209},{2.14728,0.73186},
	//{2.15796,0.73816},{2.16964,0.74532},{2.17996,0.76334},{2.1918,	0.74839},{2.20336,0.75862},{2.21376,0.75311},{2.22216,0.76176},{2.23192,0.76971},{2.2444,	0.78615},{2.25536,0.77600},
	//{2.26776,0.77671},{2.2802,	0.77356},{2.3014,	0.77907},{2.31188,0.79174},{2.32076,0.80346},{2.33152,0.78938},{2.3424,	0.80983},{2.35332,0.79717},{2.36348,0.79874},{2.3738,	0.80740},
	//{2.38348,0.81928},{2.39368,0.80983},{2.40464,0.81605},{2.41584,0.81605},{2.42644,0.80983},{2.43744,0.82636},{2.44832,0.81456},{2.45948,0.81928},{2.47012,0.83336},{2.47856,0.85224},
	//{2.48952,0.83572},{2.50296,0.84752},{2.51668,0.83895},{2.52692,0.83423},{2.53612,0.84917},{2.54476,0.86168},{2.55408,0.85862},{2.56592,0.84839},{2.57652,0.86955},{2.58636,0.84988},
	//{2.59692,0.86806},{2.60684,0.86483},{2.6152,	0.86483},{2.62364,0.88450},{2.63352,0.86483},{2.64472,0.88135},{2.65448,0.87907},{2.66376,0.87907},{2.67252,0.89079},{2.68432,0.89237},
	//{2.69284,0.88607},{2.70192,0.90504},{2.71284,0.89237},{2.72688,0.89945},{2.74112,0.89552},{2.74956,0.89158},{2.76076,0.91841},{2.76948,0.91125},{2.78148,0.92856},{2.79496,0.90976},
	//{2.8064,	0.91762},{2.81496,0.92313},{2.82704,0.91841},{2.83856,0.91676},{2.84712,0.92620},{2.8578,	0.92856},{2.8702,	0.91762},{2.88156,0.93879},{2.892,	0.94280},{2.90052,0.95374},
	//{2.91128,0.94280},{2.92648,0.93485},{2.94092,0.94437},{2.95144,0.93485},{2.96164,0.94752},{2.97316,0.95696},{2.98292,0.96790},{2.99676,0.96404},{3.02176,0.97577},{3.02988,0.96082},
	//{3.03864,0.96475},{3.0476,	0.98521},{3.05824,0.96947},{3.06856,0.97341},{3.08044,0.99072},{3.0924,	0.98285},{3.10548,0.99237},{3.11648,0.98049},{3.12512,0.99709},{3.13428,1.01039},
	//{3.145,	1.00724},{3.15736,1.01432},{3.16832,1.00338},{3.1818,	1.00574},{3.19508,1.01747},{3.20612,1.00181},{3.21448,1.02069},{3.22512,1.03006},{3.2334,	1.01511},{3.24384,1.02376},
	//{3.25472,1.02777},{3.26508,1.01983},{3.27536,1.03643},{3.28472,1.02219},{3.29556,1.02691},{3.30772,1.03242},{3.31808,1.04815},{3.32944,1.03006},{3.34052,1.04587},{3.35004,1.03564},
	//{3.36056,1.04658},{3.36876,1.04587},{3.37784,1.04972},{3.39036,1.06153},{3.40096,1.07498},{3.4142,	1.05917},{3.42724,1.07105},{3.43768,1.06389},{3.44852,1.06389},{3.45916,1.06782},
	//{3.46836,1.08993},{3.47912,1.07498},{3.49012,1.07805},{3.49884,1.08749},{3.51076,1.08749},{3.51992,1.08277},{3.52848,1.09693},{3.53684,1.08993},{3.54812,1.09378},{3.55712,1.09614},
	//{3.56976,1.10488},{3.57936,1.10873},{3.58748,1.10016},{3.5988,	1.11432},{3.6108,	1.12211},{3.62092,1.11904},{3.63268,1.11511},{3.6448,	1.13234},{3.65604,1.11817},{3.66632,1.12927},
	//{3.67744,1.13627},{3.68632,1.14729},{3.6954,	1.14972},{3.7046,	1.13478},{3.7298,	1.13706},{3.73968,1.14178},{3.75032,1.14972},{3.76116,1.15594},{3.77296,1.16223},{3.78336,1.16696},
	//{3.7948,	1.15122},{3.8068,	1.17168},{3.81916,1.15122},{3.82724,1.16617},{3.83652,1.16861},{3.84952,1.17246},{3.86108,1.18356},{3.87304,1.16774},{3.88356,1.19300}};

	int  N_muni = 610;
	double muni[][2] = {//...\EC\E8\EA\F0\EE\F8\F3\ED\E3\E8\F2;
	{0.088,  0.068044355},{0.976,  0.127688172},{1.628,  0.128528226},{2.264,  0.127688172},{2.704,  0.145329301},{3.176,  0.20749328 },{3.836,  0.229334677},{4.264,  0.260416667},{4.712,  0.268817204},{5.128,  0.267137097},
	{5.8,    0.320900538},{6.328,  0.326780914},{6.82,   0.366263441},{7.612,  0.400705645},{8.044,  0.404905914},{8.764,  0.430107527},{9.18,   0.439348118},{9.736,  0.499831989},{10.468, 0.491431452},{11.264, 0.523353495},
	{12.016, 0.558635753},{12.684, 0.551075269},{13.34,  0.59811828 },{14.1,   0.596438172},{14.868, 0.619119624},{15.488, 0.656081989},{16.112, 0.661122312},{16.876, 0.687163978},{17.3,   0.694724462},{17.704, 0.700604839},
	{18.44,  0.72328629 },{19.104, 0.75436828 },{19.736, 0.763608871},{20.42,  0.792170699},{21.184, 0.798891129},{21.852, 0.819892473},{22.468, 0.836693548},{23.216, 0.840053763},{23.624, 0.85265457 },{24.356, 0.880376344},
	{24.932, 0.902217742},{25.688, 0.898857527},{26.116, 0.908098118},{26.524, 0.934139785},{27.204, 0.933299731},{27.896, 0.953461022},{28.524, 0.979502688},{29.2,   0.977822581},{29.96,  1.00890457 },{30.624, 1.003864247},
	{31.352, 1.026545699},{32.044, 1.045866935},{32.692, 1.054267473},{34.176, 1.076948925},{34.856, 1.101310484},{35.352, 1.118951613},{36.08,  1.122311828},{36.856, 1.15843414 },{37.624, 1.149193548},{38.156, 1.165994624},
	{38.868, 1.176915323},{39.308, 1.19203629 },{39.748, 1.177755376},{40.156, 1.18531586 },{40.844, 1.205477151},{41.444, 1.233198925},{42.02,  1.228998656},{42.736, 1.255880376},{43.14,  1.240759409},{43.896, 1.267641129},
	{44.564, 1.261760753},{45.152, 1.292002688},{45.796, 1.306283602},{46.412, 1.304603495},{47.084, 1.333165323},{47.496, 1.323924731},{47.904, 1.312163978},{48.632, 1.344086022},{49.276, 1.354166667},{50.088, 1.350806452},
	{50.848, 1.375168011},{51.56,  1.358366935},{52.228, 1.386928763},{52.804, 1.397849462},{53.46,  1.41297043 },{53.864, 1.409610215},{54.276, 1.439012097},{55.024, 1.417170699},{55.664, 1.444052419},{56.356, 1.448252688},
	{57.084, 1.460013441},{57.744, 1.478494624},{58.436, 1.472614247},{59.14,  1.499495968},{59.764, 1.501176075},{60.488, 1.509576613},{60.9,   1.507056452},{61.316, 1.517977151},{62.028, 1.516297043},{62.608, 1.548219086},
	{63.308, 1.541498656},{64.076, 1.549899194},{64.748, 1.57594086 },{65.3,   1.575100806},{65.984, 1.598622312},{66.764, 1.586861559},{67.508, 1.607862903},{68.276, 1.622143817},{69.048, 1.612063172},{69.7,   1.643145161},
	{70.28,  1.635584677},{71.048, 1.653225806},{71.464, 1.650705645},{72.124, 1.671706989},{72.692, 1.679267473},{73.452, 1.685147849},{74.18,  1.697748656},{74.788, 1.686827957},{75.46,  1.71875    },{76.82,  1.723790323},
	{77.496, 1.74563172 },{78.252, 1.73891129 },{78.96,  1.760752688},{79.588, 1.762432796},{80.204, 1.771673387},{80.992, 1.790994624},{81.44,  1.792674731},{81.848, 1.784274194},{82.452, 1.806955645},{83.056, 1.813676075},
	{83.82,  1.827116935},{84.504, 1.838877688},{85.18,  1.827956989},{85.588, 1.843077957},{86.24,  1.853998656},{86.792, 1.875      },{87.544, 1.858198925},{88.324, 1.887600806},{88.968, 1.886760753},{89.576, 1.896841398},
	{90.208, 1.917002688},{90.956, 1.908602151},{91.72,  1.92624328 },{92.356, 1.927923387},{92.996, 1.933803763},{93.784, 1.950604839},{94.512, 1.94640457 },{95.2,   1.975806452},{95.872, 1.971606183},{96.44,  1.985047043},
	{97.08,  2.01108871 },{97.896, 1.997647849},{98.588, 2.02452957 },{99.168, 2.022849462},{99.884, 2.036290323},{100.596,2.050571237},{101.32, 2.034610215},{101.972,2.064012097},{102.692,2.055611559},{103.416,2.074932796},
	{104.028,2.085013441},{104.732,2.085853495},{105.144,2.100134409},{105.916,2.098454301},{106.5,  2.124495968},{107.172,2.111895161},{107.592,2.137096774},{108,    2.139616935},{108.664,2.133736559},{109.192,2.143817204},
	{109.888,2.169858871},{110.684,2.158938172},{111.428,2.1875     },{112.02, 2.184979839},{112.672,2.197580645},{113.416,2.217741935},{114.06, 2.200100806},{114.692,2.235383065},{115.332,2.232022849},{116.024,2.246303763},
	{116.724,2.253024194},{117.324,2.243783602},{118.004,2.278225806},{118.724,2.270665323},{119.364,2.282426075},{120.696,2.293346774},{121.128,2.306787634},{121.776,2.308467742},{122.292,2.335349462},{123.048,2.326108871},
	{123.456,2.346270161},{124.1,  2.342909946},{124.716,2.368111559},{125.46, 2.361391129},{126.124,2.379032258},{126.748,2.389952957},{127.452,2.373991935},{128.148,2.402553763},{128.8,  2.397513441},{129.464,2.41515457 },
	{130.116,2.423555108},{130.764,2.423555108},{131.488,2.449596774},{132.056,2.444556452},{132.704,2.466397849},{133.112,2.457157258},{133.792,2.478158602},{134.312,2.474798387},{135.048,2.480678763},{135.808,2.495799731},
	{136.408,2.500840054},{137.02, 2.526041667},{137.676,2.521841398},{138.352,2.535282258},{138.988,2.552083333},{139.588,2.545362903},{140.288,2.570564516},{140.996,2.561323925},{141.58, 2.580645161},{142.224,2.588205645},
	{142.872,2.584005376},{143.524,2.605846774},{144.22, 2.599966398},{144.904,2.620127688},{145.696,2.625168011},{146.376,2.622647849},{146.944,2.652889785},{147.64, 2.650369624},{148.316,2.668010753},{148.876,2.679771505},
	{149.496,2.683971774},{150.112,2.708333333},{150.768,2.698252688},{151.552,2.704973118},{152.18, 2.712533602},{152.668,2.719254032},{153.308,2.743615591},{154.1,  2.728494624},{154.676,2.751176075},{155.364,2.75453629 },
	{155.784,2.772177419},{156.48, 2.765456989},{156.92, 2.789818548},{157.608,2.795698925},{158.012,2.802419355},{158.632,2.804099462},{159.168,2.807459677},{159.944,2.830141129},{160.684,2.814180108},{161.256,2.844422043},
	{161.94, 2.841061828},{163.332,2.86374328 },{163.9,  2.858702957},{164.472,2.887264785},{165.176,2.878024194},{165.808,2.889784946},{166.364,2.915826613},{167.108,2.904905914},{167.788,2.926747312},{168.452,2.921706989},
	{169.044,2.935987903},{169.652,2.957829301},{170.384,2.941028226},{171.032,2.96875    },{171.636,2.961189516},{172.376,2.977990591},{172.952,2.985551075},{173.604,2.983870968},{174.008,3.002352151},{174.696,3.004032258},
	{175.264,3.027553763},{175.996,3.011592742},{176.688,3.035114247},{177.188,3.045194892},{177.772,3.041834677},{178.508,3.066196237},{179.212,3.052755376},{179.992,3.076276882},{180.644,3.072916667},{181.212,3.086357527},
	{181.956,3.108198925},{182.572,3.096438172},{183.128,3.127520161},{183.828,3.117439516},{184.512,3.130880376},{185.144,3.146001344},{185.752,3.137600806},{186.408,3.161962366},{187.18, 3.154401882},{187.772,3.167002688},
	{188.28, 3.188004032},{189.048,3.173723118},{189.624,3.203965054},{190.16, 3.193884409},{190.976,3.209005376},{191.652,3.228326613},{192.172,3.228326613},{192.968,3.245967742},{193.396,3.23000672 },{194.008,3.246807796},
	{194.468,3.245127688},{195.244,3.264448925},{195.66, 3.257728495},{196.228,3.280409946},{196.78, 3.282090054},{197.584,3.290490591},{198.252,3.290490591},{198.868,3.292170699},{199.58, 3.320732527},{200.292,3.308971774},
	{200.996,3.327452957},{201.684,3.340893817},{202.304,3.340893817},{202.928,3.369455645},{203.548,3.361055108},{203.956,3.36609543 },{204.38, 3.374495968},{205.448,3.38625672 },{206.244,3.396337366},{206.928,3.392137097},
	{207.46, 3.414818548},{208.18, 3.411458333},{208.584,3.427419355},{209.256,3.420698925},{209.772,3.441700269},{210.488,3.453461022},{210.892,3.447580645},{211.508,3.447580645},{212.02, 3.463541667},{212.668,3.483702957},
	{213.32, 3.472782258},{213.924,3.492943548},{214.636,3.492943548},{215.32, 3.501344086},{215.992,3.518145161},{216.62, 3.508064516},{217.292,3.533266129},{217.92, 3.532426075},{218.692,3.528225806},{219.368,3.550907258},
	{219.976,3.548387097},{220.74, 3.571068548},{221.328,3.564348118},{221.96, 3.579469086},{222.368,3.57358871 },{223.004,3.590389785},{223.476,3.594590054},{224.212,3.598790323},{224.644,3.602150538},{225.32, 3.616431452},
	{225.78, 3.638272849},{226.504,3.623991935},{227.156,3.648353495},{227.748,3.642473118},{228.512,3.65171371 },{229.08, 3.659274194},{229.672,3.662634409},{230.416,3.682795699},{231.032,3.675235215},{231.672,3.694556452},
	{232.352,3.705477151},{232.928,3.710517473},{233.656,3.727318548},{234.368,3.712197581},{234.96, 3.735719086},{235.62, 3.739079301},{236.268,3.738239247},{236.82, 3.760920699},{237.576,3.748319892},{237.98, 3.77016129 },
	{238.584,3.760080645},{239.108,3.797883065},{239.88, 3.786122312},{240.584,3.791162634},{241.16, 3.812163978},{241.848,3.796202957},{242.468,3.826444892},{243.08, 3.81468414 },{243.832,3.828125   },{244.504,3.832325269},
	{245.116,3.836525538},{245.8,  3.860047043},{246.364,3.854166667},{247.692,3.87936828 },{248.348,3.882728495},{249.056,3.902049731},{249.724,3.891129032},{250.224,3.914650538},{250.98, 3.923051075},{251.664,3.909610215},
	{252.22, 3.937331989},{252.928,3.925571237},{253.656,3.944052419},{254.18, 3.946572581},{254.856,3.945732527},{255.576,3.976814516},{256.092,3.966733871},{256.74, 3.986055108},{257.44, 3.99109543 },{258.036,3.991935484},
	{258.72, 4.015456989},{259.356,4.002856183},{259.92, 4.023857527},{260.624,4.025537634},{261.264,4.025537634},{261.744,4.04905914 },{262.44, 4.039818548},{263.164,4.059979839},{263.832,4.04905914 },{264.372,4.065020161},
	{265.08, 4.08938172 },{265.756,4.074260753},{266.352,4.096942204},{266.916,4.100302419},{267.464,4.115423387},{268.1,  4.125504032},{268.852,4.109543011},{269.368,4.140625   },{269.996,4.144825269},{270.424,4.148185484},
	{271.044,4.135584677},{271.512,4.163306452},{272.268,4.16750672 },{272.92, 4.166666667},{273.56, 4.189348118},{274.104,4.177587366},{274.816,4.197748656},{275.252,4.180947581},{275.9,  4.207829301},{276.42, 4.204469086},
	{277.116,4.221270161},{277.772,4.236391129},{278.512,4.219590054},{279.108,4.243111559},{279.764,4.241431452},{280.516,4.251512097},{281.12, 4.259912634},{281.768,4.252352151},{282.296,4.287634409},{282.892,4.275033602},
	{283.524,4.296034946},{284.232,4.292674731},{284.876,4.296034946},{285.436,4.325436828},{286.1, 4.311995968 },{286.748,4.335517473},{287.328,4.335517473},{287.98, 4.334677419},{288.644,4.364079301},{289.86, 4.369119624},
	{290.584,4.370799731},{291.244,4.365759409},{291.884,4.38844086 },{292.584,4.379200269},{293.204,4.401041667},{293.86, 4.40188172 },{294.468,4.407762097},{295.032,4.43296371 },{295.748,4.417842742},{296.376,4.442204301},
	{296.884,4.454805108},{297.584,4.453965054},{298.248,4.471606183},{298.824,4.462365591},{299.476,4.482526882},{300.116,4.482526882},{300.716,4.480846774},{301.272,4.506048387},{302.032,4.490087366},{302.572,4.518649194},
	{303.14, 4.518649194},{303.788,4.527049731},{304.488,4.543850806},{305.14, 4.534610215},{305.612,4.568212366},{306.28, 4.559811828},{306.932,4.570732527},{307.456,4.585013441},{308.148,4.570732527},{308.82, 4.595094086},
	{309.324,4.59593414 },{309.96, 4.611055108},{310.66, 4.611895161},{311.292,4.606014785},{311.876,4.642137097},{312.476,4.62953629 },{313.156,4.640456989},{313.776,4.654737903},{314.368,4.654737903},{315.044,4.681619624},
	{315.676,4.670698925},{316.228,4.689180108},{316.896,4.70094086 },{317.496,4.692540323},{318.108,4.712701613},{318.724,4.710181452},{319.32, 4.727822581},{320.028,4.724462366},{320.568,4.726982527},{321.176,4.762264785},
	{321.852,4.742103495},{322.432,4.763104839},{322.964,4.77234543 },{323.664,4.769825269},{324.376,4.788306452},{324.796,4.783266129},{325.412,4.806787634},{326.104,4.808467742},{326.596,4.808467742},{327.272,4.832829301},
	{327.972,4.815188172},{328.448,4.844590054},{329,    4.845430108},{329.688,4.846270161},{330.276,4.86391129 },{331.556,4.879872312},{332.052,4.882392473},{332.74, 4.889112903},{333.348,4.90843414 },{333.916,4.897513441},
	{334.56, 4.925235215},{335.096,4.924395161},{335.724,4.925235215},{336.364,4.94203629 },{336.9,  4.936995968},{337.492,4.964717742},{338.108,4.961357527},{338.7,  4.961357527},{339.34, 4.97983871 },{339.952,4.972278226},
	{340.552,5.000840054},{341.08, 4.999159946},{341.712,5.015120968},{342.24, 5.029401882},{342.88, 5.021001344},{343.512,5.042002688},{344.02, 5.037802419},{344.732,5.050403226},{345.42, 5.058803763},{345.996,5.053763441},
	{346.536,5.082325269},{347.124,5.076444892},{347.808,5.085685484},{348.328,5.092405914},{348.924,5.09156586 },{349.568,5.121807796},{350.128,5.110047043},{350.74, 5.127688172},{351.48, 5.132728495},{351.912,5.144489247},
	{352.624,5.164650538},{353.04, 5.141969086},{353.672,5.164650538},{354.28, 5.15625	  },{354.916,5.183971774},{355.464,5.182291667},{356.184,5.191532258},{356.764,5.209173387},{357.368,5.198252688},{358.008,5.230174731},
	{358.588,5.216733871},{359.264,5.231854839},{359.84, 5.243615591},{360.468,5.235215054},{361.092,5.262936828},{361.652,5.255376344},{362.276,5.270497312},{362.92, 5.277217742},{363.464,5.279737903},{364.016,5.306619624},
	{364.612,5.293178763},{365.044,5.320060484},{365.7,  5.33266129 },{366.344,5.324260753},{366.86, 5.350302419},{367.548,5.33938172 },{368.144,5.357862903},{368.644,5.367943548},{369.256,5.362063172},{369.84, 5.388104839},
	{370.408,5.380544355},{371.5,  5.404905914},{372.136,5.403225806},{372.66, 5.435987903},{373.116,5.434307796},{373.696,5.452788978},{374.34, 5.454469086},{374.84, 5.456149194},{375.436,5.483030914},{376.08, 5.464549731},
	{376.564,5.488071237},{377.132,5.496471774},{377.864,5.489751344},{378.368,5.516633065},{378.824,5.514112903},{379.508,5.531754032},{380.08, 5.523353495},{380.56, 5.535114247},{381.16, 5.56031586 },{381.824,5.543514785},
	{382.364,5.571236559},{382.836,5.577116935},{383.476,5.583837366},{384.02, 5.608198925},{384.572,5.592237903},{385.216,5.619959677},{385.672,5.61827957 },{386.312,5.619119624},{386.832,5.637600806},{387.292,5.63844086 }};

//	int  N_muni = 1304;
//	double muni[][2] = {//...\ED\E0\ED\EE\F8\F3\ED\E3\E8\F2;
//   {1.00096,0.06129 },{1.00412,0.091935},{1.00992,0.146774},{1.01704,0.158065},{ 1.024 ,0.157258},{1.02928,0.204032},{1.03224,0.237097},{1.03428,0.254032},{1.03692,0.28871 },{1.04092,0.341129},
//	{1.04612,0.328226},{1.05164,0.356452},{1.05656,0.405645},{1.06076,  0.4   },{ 1.064 ,0.419355},{ 1.067 ,0.480645},{1.07048,0.487903},{ 1.075 ,0.491129},{1.08028,0.535484},{1.08576,0.550806},
//	{1.09064,0.548387},{ 1.0944,0.579032},{1.09748,0.623387},{1.10076,0.617742},{1.10512,0.645161},{1.11092,0.678226},{1.11716,0.675806},{1.12284,0.678226},{1.12736,0.715323},{1.13104,0.729839},
//	{ 1.1346,0.732258},{1.13852,0.773387},{1.14276,0.794355},{ 1.1476,0.794355},{ 1.1522,0.81371 },{ 1.1564,0.841129},{1.16068,0.846774},{ 1.1648,0.862097},{1.16904,0.879032},{1.17368,0.904839},
//	{1.17828,0.903226},{1.18316,0.926613},{ 1.1882,0.942742},{1.19312,0.948387},{1.19788,0.959677},{1.20192,0.982258},{1.20552,1.002419},{1.20948,1.005645},{ 1.2142,1.023387},{ 1.2196,1.044355},
//	{1.22484,1.042742},{1.22936,1.045161},{1.23332,1.081452},{1.23696,1.089516},{ 1.241 ,1.097581},{1.24568,1.112903},{1.25108,1.137903},{1.25672,1.124194},{ 1.2618,1.141935},{1.26632,1.166935},
//	{ 1.2708,1.159677},{1.27504,1.176613},{1.27936,1.206452},{1.28384,1.210484},{1.28848,1.210484},{ 1.293 ,1.237903},{ 1.2972,1.254839},{ 1.3014,1.254032},{1.30612,1.259677},{1.31132,1.291935},
//	{ 1.3166,1.277419},{1.32156,1.293548},{ 1.3254,1.322581},{1.32904,1.326613},{1.33308,1.331452},{ 1.3378,1.350806},{1.34296,1.36371 },{1.34844,1.350806},{1.35388,1.366129},{1.35928,1.390323},
//	{1.36376,1.38629 },{1.36752,1.396774},{1.37132,1.429032},{1.37576,1.421774},{1.38068,1.431452},{1.38588,1.435484},{1.39068,1.459677},{1.39484,1.455645},{1.39844,1.473387},{1.40212,1.502419},
//	{1.40664,1.491935},{1.41208,1.504032},{1.41808,1.512903},{1.42348,1.516935},{ 1.428 ,1.521774},{1.43212,1.541129},{1.43612,1.56129 },{1.44064,1.56129 },{1.44564,1.558065},{ 1.4508,1.590323},
//	{1.45584,1.583871},{1.46012,1.589516},{ 1.4642,1.606452},{1.46836,1.618548},{ 1.4726,1.627419},{1.47712,1.631452},{1.48172,1.659677},{1.48644,1.647581},{1.49128,1.653226},{1.49616,1.685484},
//	{1.50088,1.678226},{1.50504,1.682258},{1.50952,1.702419},{1.51432,1.71129 },{1.51908,1.716129},{1.52336,1.714516},{1.52704,1.759677},{1.53108,1.741935},{1.53568,1.754839},{1.54044,1.779032},
//	{ 1.545 ,1.766935},{1.54952,1.783065},{ 1.5544,1.781452},{1.55956,1.809677},{1.56464,1.798387},{1.56948,1.806452},{1.57352,1.841129},{1.57704,1.829839},{1.58008,1.843548},{1.58348,1.871774},
//	{1.58784,1.862097},{1.59316,1.866129},{ 1.5992,1.875806},{1.60524,1.895968},{1.61088,1.877419},{ 1.615 ,1.903226},{1.61792,1.926613},{ 1.6204, 1.925  },{1.62372,1.939516},{ 1.6284,1.951613},
//	{1.63368,1.96371 },{1.63936,1.944355},{1.64472,1.970161},{1.64916,1.982258},{1.65316,1.978226},{1.65756,1.991935},{1.66216,2.006452},{ 1.6666,2.010484},{1.67096,2.009677},{1.67508,2.028226},
//	{1.68004,2.041935},{ 1.6856,2.035484},{1.69056,2.053226},{1.69488,2.066129},{1.69868,2.06129 },{1.70256,2.076613},{1.70684,2.097581},{1.71152,2.097581},{1.71616,2.093548},{1.72076,2.121774},
//	{1.72488,2.123387},{1.72876,2.129032},{1.73284,2.135484},{ 1.7372,2.159677},{ 1.7418,2.153226},{1.74652,2.156452},{1.75116,2.184677},{1.75528,2.177419},{1.75928,2.189516},{1.76332,2.202419},
//	{1.76772,2.224194},{1.77248,2.209677},{1.77708,2.224194},{1.78128,2.245968},{ 1.7854,2.242742},{ 1.7896,2.243548},{1.79368,2.269355},{ 1.7978,2.274194},{1.80204,2.270968},{ 1.8064,2.289516},
//	{1.81104,2.302419},{1.81548,2.292742},{1.81948,2.309677},{1.82336,2.331452},{1.82728,2.328226},{ 1.831 ,2.337097},{ 1.8348,2.358871},{ 1.839 ,2.366935},{1.84364,2.358871},{1.84808,2.381452},
//	{1.85168,2.387097},{ 1.8552,2.394355},{1.85932,2.393548},{1.86412, 2.425  },{1.86908,2.412097},{1.87344,2.415323},{1.87736,2.445968},{1.88112,2.445968},{1.88496,2.454839},{1.88948,2.458065},
//	{1.89424,2.480645},{1.89848,2.467742},{1.90196,2.484677},{1.90488,2.508871},{1.90868,2.514516},{1.91364,2.509677},{1.91856,2.528226},{ 1.9228,2.540323},{1.92624,2.529839},{1.92968,2.551613},
//	{1.93344,2.570968},{ 1.9378,2.568548},{1.94232,2.579032},{ 1.9466,2.592742},{ 1.9506,  2.6   },{1.95436,2.595161},{1.95816,2.619355},{1.96208,2.631452},{ 1.966 ,2.620968},{1.96988,2.645968},
//	{ 1.9738,2.662097},{1.97804,2.66129 },{1.98224,2.659677},{1.98628,2.691935},{1.99048,2.687903},{1.99464,2.68629 },{ 1.999 ,2.709677},{ 2.0034,2.712097},{ 2.0074,2.716129},{ 2.0108,2.729032},
//	{ 2.0142,2.760484},{2.01796,2.745161},{2.02196,2.760484},{ 2.026 ,2.777419},{2.02988,2.787097},{2.03376,2.782258},{2.03744,2.808065},{2.04128,2.81129 },{2.04552,2.81129 },{2.04996,2.821774},
//	{2.05436,2.839516},{2.05832,2.839516},{2.06184,2.849194},{2.06508, 2.875  },{2.06848,2.879839},{2.07264,2.884677},{2.07708,2.88629 },{ 2.081 ,2.906452},{ 2.0842,2.901613},{2.08688,2.916129},
//	{2.09036,2.943548},{2.09512,2.941935},{2.10008,2.935484},{ 2.1042,2.959677},{2.10776,2.965323},{2.11084,2.966129},{2.11432,2.98871 },{ 2.1182,3.008871},{2.12268,3.001613},{2.12684,3.008871},
//	{2.13012,3.033871},{2.13316,3.031452},{2.13672,3.041935},{2.14104,3.055645},{ 2.1456,3.070968},{2.14964,3.055645},{ 2.1532,3.087097},{ 2.1562,3.103226},{2.15948,3.106452},{2.16328,3.105645},
//	{ 2.1674,3.128226},{2.17144,3.127419},{ 2.175 , 3.125  },{2.17772,3.157258},{2.18076,3.164516},{2.18504,3.173387},{2.18992,3.169355},{2.19436,3.195968},{2.19796,3.183065},{2.20096,3.204839},
//	{2.20412,3.220968},{2.20804,3.231452},{2.21224,3.228226},{2.21628,3.245968},{2.21984,3.262097},{2.22272,3.260484},{2.22588,3.275806},{2.22984,3.294355},{2.23428,3.295161},{2.23836,3.292742},
//	{2.24148, 3.325  },{2.24456,3.329839},{2.24844, 3.325  },{2.25272,3.339516},{2.25652,3.36371 },{2.26012,3.353226},{2.26372,3.367742},{2.26764,3.392742},{ 2.2712,3.392742},{2.27432,3.396774},
//	{2.27772,3.420968},{2.28144,3.428226},{2.28488,3.424194},{2.28832,  3.45  },{2.29208,3.459677},{2.29584,3.459677},{ 2.2996,3.468548},{2.30344,3.494355},{2.30724,3.490323},{2.31132,3.494355},
//	{ 2.3152,3.515323},{2.31828,3.528226},{ 2.3214,3.532258},{2.32504,3.554032},{2.32924,3.562097},{ 2.3334,3.557258},{2.33688,3.565323},{2.33964,3.595161},{2.34268,3.598387},{2.34624,3.606452},
//	{2.35036,3.624194},{2.35472,3.630645},{2.35884,3.626613},{2.36196,3.63629 },{2.36472,3.668548},{2.36804,3.659677},{2.37232,3.674194},{2.37648,3.690323},{2.37984,3.698387},{2.38264,3.699194},
//	{ 2.3858, 3.725  },{2.38968,3.735484},{2.39368,3.722581},{2.39744,3.737903},{2.40076,3.76129 },{2.40376,3.766129},{ 2.4066,3.771774},{2.40992,3.804839},{2.41396,3.794355},{2.41776,3.795161},
//	{2.42108,3.814516},{ 2.424 ,3.841129},{2.42708,3.828226},{ 2.431 ,3.848387},{2.43532,3.862903},{2.43944,3.865323},{2.44252,3.873387},{2.44476,3.904839},{2.44772,3.912097},{2.45156,3.906452},
//	{2.45584,3.929839},{2.46004,3.937903},{ 2.4634,3.934677},{2.46636,3.943548},{ 2.4696,3.978226},{2.47332,3.968548},{ 2.477 ,3.975806},{ 2.4802,3.995968},{2.48316,4.01371 },{2.48624,4.009677},
//	{ 2.4898,4.029032},{2.49364,4.045161},{2.49712,4.040323},{2.50036,4.053226},{2.50336,4.076613},{2.50684,4.08629 },{2.51092,4.076613},{ 2.5152,4.108871},{2.51904,4.112903},{2.52196,4.118548},
//	{2.52452,4.133065},{2.52764,4.16129 },{2.53136,4.150806},{2.53516,4.160484},{2.53844,4.185484},{2.54132,4.187097},{2.54432,4.191129},{ 2.5476,4.216129},{2.55104,4.230645},{ 2.5544, 4.225  },
//	{2.55796,4.244355},{2.56192,4.26129 },{2.56572,4.258065},{ 2.5688,4.266129},{2.57156,4.301613},{2.57492,4.297581},{2.57844,4.301613},{2.58152,4.320968},{2.58452,4.342742},{2.58752,4.329839},
//	{ 2.5908,4.349194},{2.59416,4.372581},{2.59784,4.369355},{2.60148,4.376613},{2.60468,4.398387},{2.60772,4.409677},{2.61084,4.408065},{2.61388,4.435484},{2.61704,4.445161},{2.62032,4.445968},
//	{2.62392,4.455645},{2.62772,4.480645},{ 2.631 , 4.475  },{2.63408,4.48629 },{2.63736,4.507258},{2.64072,4.520968},{2.64428,4.521774},{2.64788,4.540323},{2.65132,4.556452},{2.65428,4.548387},
//	{2.65708,4.570161},{2.66016,4.590323},{2.66348,4.591935},{2.66652,4.597581},{2.66964,4.627419},{2.67316,4.629839},{2.67668,4.630645},{2.67984,4.645161},{2.68236,4.674194},{ 2.685 , 4.675  },
//	{2.68804,4.684677},{2.69144,4.712903},{ 2.695 ,4.705645},{2.69848,4.712903},{ 2.7016,4.730645},{2.70476,4.748387},{2.70796,4.745161},{ 2.711 ,4.770968},{ 2.714 ,4.78629 },{2.71712,4.787903},
//	{2.72044,4.789516},{2.72396,4.816935},{2.72752,4.814516},{2.73104,4.819355},{2.73436,4.844355},{ 2.7378,4.862903},{2.74156,4.852419},{ 2.7446,4.875806},{ 2.747 ,4.904032},{2.74968,4.893548},
//	{ 2.7532,4.905645},{2.75676,4.927419},{2.75972,4.937903},{ 2.7624,4.935484},{2.76536,4.966129},{2.76852,4.976613},{ 2.772 ,4.975806},{ 2.7752,4.983871},{ 2.7782,5.01371 },{2.78128,5.005645},
//	{2.78452,5.020161},{2.78784,5.043548},{ 2.791 ,5.047581},{2.79408,5.047581},{ 2.797 ,5.070161},{2.79984,5.085484},{2.80284,5.083065},{2.80608,5.102419},{2.80948,5.118548},{2.81252,5.122581},
//	{2.81536,5.130645},{2.81824,5.158065},{2.82116,5.160484},{2.82412,5.166129},{2.82736,5.175806},{2.83068,5.198387},{2.83368,5.194355},{2.83628,5.21129 },{ 2.839 ,5.235484},{2.84228,5.241935},
//	{ 2.8456,5.239516},{2.84868,5.262097},{2.85176,5.273387},{2.85488,5.271774},{2.85768,  5.3   },{2.86068,5.320161},{2.86384,5.318548},{2.86676,5.318548},{2.86968,  5.35  },{2.87292,  5.35  },
//	{ 2.8762,5.353226},{2.87948,5.378226},{2.88264,5.389516},{2.88564,5.383871},{2.88872,5.404032},{ 2.892 ,5.422581},{2.89524,5.412903},{2.89844,5.430645},{ 2.9014,5.454839},{2.90432,5.466935},
//	{ 2.907 ,5.467742},{ 2.9098,5.491129},{2.91284,5.506452},{ 2.916 ,5.504839},{2.91904,5.514516},{ 2.9216,5.541129},{2.92356,5.540323},{2.92608,5.558871},{2.92944,5.578226},{ 2.933 ,5.578226},
//	{2.93548,5.581452},{2.93744,5.604839},{2.93996,5.623387},{ 2.9434,5.612097},{ 2.947 ,5.629032},{2.95008,5.645161},{2.95268,5.652419},{2.95544,5.655645},{2.95832,5.687903},{ 2.9616,5.685484},
//	{2.96492,5.687097},{2.96796,5.710484},{2.97012,5.730645},{2.97228,5.73629 },{2.97532,5.745161},{2.97912,5.766935},{2.98276,5.76129 },{2.98552,5.769355},{2.98772,5.791935},{2.99008,5.816129},
//	{ 2.9936,5.806452},{ 2.9974,5.829839},{ 3.0002,5.842742},{3.00232,5.854032},{3.00504,5.858065},{3.00852,5.88871 },{3.01228,5.884677},{3.01568,5.887903},{3.01864,5.912903},{3.02088,5.928226},
//	{3.02336,5.932258},{3.02636,5.945968},{3.02968,5.968548},{3.03268,5.956452},{3.03484,5.978226},{3.03708,5.997581},{3.03956,6.008871},{3.04208,6.002419},{3.04476,6.031452},{3.04712,6.040323},
//	{3.04968,6.043548},{3.05252,6.051613},{ 3.0552,6.078226},{3.05792,6.079032},{3.06104,6.093548},{ 3.0648,6.115323},{3.06832,6.116935},{3.07108,6.121774},{3.07312,6.141935},{3.07508,6.169355},
//	{3.07772,6.162097},{ 3.081 ,6.178226},{3.08412,6.198387},{3.08664,6.202419},{ 3.089 ,  6.2   },{3.09164,6.235484},{3.09444,6.234677},{3.09732,6.23871 },{3.10056,6.264516},{3.10392,6.276613},
//	{3.10736,6.269355},{3.11044,6.283871},{3.11284,6.316129},{ 3.115 ,6.315323},{3.11764,6.326613},{3.12072,6.347581},{3.12384,6.358871},{3.12656,6.356452},{ 3.129 ,6.383871},{3.13136,6.401613},
//	{ 3.1342,6.399194},{3.13696,6.409677},{ 3.1392,6.437903},{3.14128,6.434677},{ 3.144 ,6.443548},{3.14768,6.466935},{3.15116,6.475806},{ 3.1536,6.483065},{3.15548,  6.5   },{3.15828, 6.525  },
//	{3.16184,6.514516},{3.16492,6.528226},{3.16708,6.556452},{3.16892,6.565323},{ 3.1712,6.562903},{3.17344,6.593548},{3.17604,  6.6   },{3.17932,6.595968},{3.18256,6.612097},{3.18548,6.632258},
//	{3.18808,6.637097},{ 3.1906,6.645161},{3.19296, 6.675  },{ 3.1956, 6.675  },{3.19852,6.676613},{3.20148,6.693548},{3.20444,6.718548},{3.20728,6.707258},{3.20956,6.733871},{3.21176,6.758065},
//	{3.21412,6.759677},{3.21684,6.762097},{ 3.2196,6.791935},{3.22216,6.791935},{3.22468,6.797581},{3.22736,6.818548},{  3.23 ,6.83629 },{3.23216,6.830645},{3.23428,6.852419},{3.23672,6.880645},
//	{3.23936,6.873387},{ 3.2422,6.881452},{3.24524,6.907258},{3.24836,6.919355},{3.25104,6.918548},{3.25304,6.941935},{3.25496,6.957258},{3.25728,6.952419},{3.25968,6.962903},{3.26216,6.984677},
//	{ 3.2646,6.987097},{3.26716,6.996774},{3.26992,7.023387},{3.27296,7.030645},{3.27604,7.030645},{3.27888,7.041129},{3.28128,7.066935},{3.28288,7.057258},{3.28456,7.081452},{3.28712,7.104839},
//	{3.29036,7.107258},{3.29328,7.104839},{ 3.2956,7.141935},{ 3.2978,7.145968},{3.30008,7.145968},{3.30208,7.162903},{3.30432,7.184677},{3.30692,7.184677},{3.30964,7.18871 },{3.31204,7.220968},
//	{3.31452,7.218548},{3.31708,7.226613},{3.31976,7.247581},{3.32236,7.266935},{3.32492,7.257258},{3.32752,7.280645},{3.32976,7.295968},{3.33156,7.304839},{3.33372,7.309677},{3.33648,7.33871 },
//	{3.33932,7.341129},{3.34172,7.341935},{3.34408,7.374194},{ 3.3466,7.38629 },{3.34932,7.380645},{ 3.3518,7.395968},{3.35384,7.422581},{3.35592,7.415323},{ 3.3588,7.428226},{3.36184,7.447581},
//	{3.36452,7.462097},{3.36688,7.46129 },{ 3.3686,7.485484},{3.37032,7.507258},{3.37264,7.499194},{ 3.3756,7.51129 },{3.37844,7.537097},{3.38088,7.537903},{3.38304,7.544355},{3.38508,7.575806},
//	{3.38728,7.574194},{ 3.3898,7.583871},{3.39248,7.595968},{3.39508,7.614516},{3.39748,7.612903},{3.39976,7.628226},{3.40208,7.652419},{ 3.4044,7.659677},{ 3.4068,7.662097},{3.40928,7.685484},
//	{3.41156,7.690323},{3.41368,7.691935},{3.41616,7.716129},{3.41868,7.735484},{3.42108,7.739516},{3.42368,7.748387},{3.42644,7.776613},{3.42912,7.776613},{3.43152,7.779839},{ 3.4336,7.805645},
//	{ 3.4358, 7.825  },{3.43816,7.819355},{3.44056,7.845161},{3.44288,7.862903},{3.44488,7.858065},{3.44728,7.866129},{3.44996,7.893548},{3.45224,  7.9   },{3.45416,7.901613},{3.45684,7.935484},
//	{3.46012,7.947581},{3.46296,7.942742},{3.46512,7.958871},{3.46736,7.992742},{3.46964,7.977419},{3.47192,7.999194},{3.47392,8.025806},{3.47612,8.030645},{3.47856,8.022581},{ 3.481 ,  8.05  },
//	{3.48316,8.065323},{ 3.485 ,8.06371 },{3.48748,8.084677},{3.49056,  8.1   },{ 3.4932,8.104839},{3.49532,8.115323},{3.49732,8.148387},{3.49956,8.148387},{3.50192,8.154839},{3.50436,8.164516},
//	{3.50668,8.18629 },{ 3.5092,8.175806},{ 3.5118,8.196774},{ 3.514 ,8.224194},{3.51604,8.225806},{ 3.5186,8.231452},{3.52124,8.253226},{3.52352,8.26371 },{ 3.5256,8.262097},{3.52796,8.292742},
//	{3.53064,8.308871},{3.53292,8.312097},{3.53468,8.321774},{ 3.5366,8.353226},{3.53896,8.346774},{3.54136,8.351613},{3.54336,8.371774},{3.54588,8.390323},{ 3.5488,8.38629 },{ 3.5514,8.407258},
//	{3.55368,8.425806},{3.55568,8.427419},{3.55788,8.433871},{3.56024,8.458871},{3.56244,8.467742},{ 3.5644,8.466129},{3.56608,8.498387},{3.56824,8.509677},{3.57088,8.508871},{3.57332,8.518548},
//	{3.57516,8.551613},{3.57672,8.541129},{3.57884,8.558871},{3.58192,8.583065},{3.58516,8.583871},{ 3.5876,8.581452},{3.58932,8.617742},{3.59104,8.635484},{3.59328,8.625806},{3.59552,8.646774},
//	{3.59748,8.66371 },{3.59928,8.670161},{3.60092,8.677419},{3.60256,8.716129},{3.60464,8.712097},{3.60736,8.712903},{3.60996,8.730645},{3.61192,  8.75  },{3.61404,8.744355},{3.61652,8.764516},
//	{ 3.6192,8.791129},{3.62116,8.791935},{3.62252,8.802419},{ 3.6244,8.822581},{3.62684,8.827419},{3.62932,8.822581},{3.63168,8.852419},{3.63432,8.864516},{ 3.637 ,8.86129 },{3.63944,8.872581},
//	{3.64136,8.908065},{ 3.643 ,8.904839},{3.64512,8.914516},{3.64804,8.93629 },{3.65104,8.939516},{ 3.6534,8.941935},{3.65496,8.964516},{3.65656,8.993548},{3.65896,8.983065},{3.66196,8.985484},
//	{3.66432,9.012097},{3.66608,9.021774},{3.66824, 9.025  },{3.67092,9.056452},{3.67356,9.064516},{3.67612,9.060484},{3.67772,9.067742},{3.67896,9.107258},{3.68092,9.104839},{3.68364,9.109677},
//	{3.68616,9.140323},{3.68784,9.144355},{3.68952,9.146774},{ 3.6916,9.176613},{3.69376,9.187097},{ 3.696 ,9.177419},{3.69804,9.21129 },{3.70032,9.228226},{ 3.7028,9.221774},{3.70476,9.233065},
//	{3.70608,9.269355},{3.70772,9.266129},{3.71004,9.262903},{3.71252,9.279839},{3.71452,9.295161},{3.71592,9.293548},{ 3.7176,9.315323},{ 3.7202,9.337097},{3.72268,9.332258},{3.72452,9.345968},
//	{ 3.7264,9.369355},{ 3.7288,9.376613},{3.73116,9.377419},{3.73292,9.410484},{3.73476, 9.425  },{3.73688,9.422581},{3.73936,9.427419},{3.74196,9.46129 },{3.74392,9.465323},{3.74608,9.479032},
//	{ 3.7486,9.502419},{ 3.751 ,9.503226},{3.75316,  9.5   },{ 3.7546,9.522581},{3.75628,9.545968},{ 3.7592,9.53871 },{3.76252,9.550806},{3.76448,9.575806},{3.76536,9.591129},{3.76716,9.591129},
//	{3.76992,9.615323},{3.77216,9.615323},{3.77356,9.616935},{ 3.775 ,9.63629 },{3.77704,9.658065},{3.77948,9.655645},{ 3.7818,9.667742},{ 3.7834,9.696774},{ 3.7848,9.695161},{3.78656,9.701613},
//	{3.78848,9.725806},{3.79044,9.741129},{3.79248,9.739516},{3.79472,9.769355},{ 3.797 ,9.784677},{3.79948,9.789516},{3.80172,9.793548},{ 3.8036,9.827419},{3.80552,9.833871},{ 3.8076,9.833871},
//	{3.80928,9.859677},{3.81088,9.878226},{3.81304,9.874194},{ 3.8156,9.892742},{3.81736,9.91129 },{3.81884,9.906452},{3.82076,9.923387},{3.82344,9.941935},{3.82596,9.951613},{3.82784,9.93629 },
//	{3.82896,9.959677},{3.83012,9.965323},{ 3.832 ,9.956452},{3.83388,9.974194},{3.83528,10.00645},{ 3.837 ,10.00726},{3.83924,10.02258},{ 3.8416,10.04435},{3.84348,10.05242},{3.84496,10.05645},
//	{3.84672,10.07903},{3.84904,10.10403},{3.85068,10.09919},{3.85232,10.12258},{3.85444,10.14677},{3.85708,10.14758},{ 3.8596,10.14274},{3.86108, 10.175 },{3.86244,10.18629},{3.86492,10.19113},
//	{3.86788,10.20726},{3.87004,10.22742},{3.87164,10.22823},{3.87332,10.23629},{3.87496,10.26371},{ 3.8762,10.26371},{3.87804,10.26855},{ 3.8804,10.29274},{ 3.8822,10.30565},{ 3.8834,10.30161},
//	{3.88472,10.33468},{ 3.8868,10.34839},{3.88908,10.34677},{3.89132,10.35323},{3.89332,10.38065},{3.89508,10.37742},{3.89688,10.38145},{3.89888,10.40887},{3.90104,10.42016},{3.90304,10.41694},
//	{3.90484,10.43226},{ 3.9066,10.45484},{3.90864,10.44839},{3.91068,10.46613},{3.91244,10.48306},{3.91384,10.49597},{3.91532,10.49274},{ 3.9172,10.51371},{3.91904,10.52903},{3.92048,10.52742},
//	{ 3.9222,10.53871},{3.92432,10.5629 },{3.92608,10.55968},{3.92756,10.56935},{3.92916,10.59758},{3.93088,10.60081},{3.93316,  10.6  },{3.93548,10.61532},{ 3.9376,10.6371 },{ 3.9392,10.62984},
//	{3.94064,10.65242},{3.94264,10.67016},{3.94488,10.66855},{3.94672,10.6629 },{ 3.948 ,10.69516},{3.94912,  10.7  },{3.95096,10.70081},{3.95356,10.73145},{3.95596,10.74194},{3.95768,10.73306},
//	{3.95896,10.74597},{3.96056,10.77581},{3.96268,10.77097},{3.96432,10.78387},{ 3.966 ,10.80726},{3.96812,10.81452},{3.97004,10.80081},{3.97132,10.82177},{3.97256,10.8379 },{3.97424,10.8371 },
//	{3.97636,10.84435},{3.97844,10.87419},{3.97992,10.87258},{3.98116,10.88226},{ 3.983 ,10.91532},{3.98532, 10.925 },{3.98764,10.92097},{ 3.9896,10.93065},{3.99128,10.95565},{ 3.9926,10.94919},
//	{3.99384,10.96532},{ 3.9956,10.9871 },{3.99724,10.98952},{3.99856,10.98629},{4.00032,11.01452},{4.00228,11.03226},{4.00408,11.02339},{4.00588,11.04677},{4.00776,11.07258},{4.00964,11.06774},
//	{4.01168,11.07258},{4.01372,11.11048},{4.01532,11.11371},{ 4.0168,11.12097},{4.01884, 11.15  },{4.02104,11.16694},{4.02316,11.15484},{4.02488,11.18145},{4.02656,11.20645},{4.02856,11.20484},
//	{ 4.0306,11.21129},{ 4.0326,11.2379 },{4.03392,11.24677},{4.03512,11.25161},{ 4.0372,11.27339},{4.03932,11.2871 },{4.04088,11.28226},{4.04212,11.30403},{4.04372,11.33387},{4.04552,11.32903},
//	{ 4.0476,11.33952},{4.04976,11.35887},{ 4.0516,11.37258},{4.05352,11.36935},{ 4.0556,11.39597},{4.05732,11.42097},{4.05916,11.42419},{4.06112,11.44113},{4.06324,11.46371},{4.06516,11.46129},
//	{4.06668,11.46855},{ 4.0684,11.49919},{4.07008,11.51452},{4.07212,11.51048},{4.07424,11.50887},{4.07576,11.5379 },{4.07684,11.53387},{ 4.0786,11.55323},{4.08124,11.57742},{4.08364,11.57661},
//	{4.08528,11.57339},{4.08664,11.61129},{4.08828, 11.625 },{4.09056,11.62339},{4.09308,11.64355},{ 4.0952,11.6629 },{4.09696,11.66694},{4.09864,11.67419},{ 4.1006,11.70968},{ 4.1028,11.70806},
//	{4.10508,11.71694},{4.10684,11.73306},{4.10844,11.75242},{4.11048,11.74677},{4.11292,11.77097},{ 4.115 ,11.78952},{4.11672,11.7871 },{ 4.1182,11.79919},{4.11992,11.82742},{4.12156,11.83548},
//	{ 4.123 ,11.83629},{4.12536,11.8621 },{4.12808,11.87016},{4.12988,11.86855},{4.13096,11.88629},{4.13324,11.91935},{ 4.1364,11.90242},{4.13892,11.91694},{4.14028,11.94113},{4.14132,11.96129},
//	{4.14296,11.95887},{4.14548,11.98065},{ 4.148 ,11.99194},{4.14992,11.98226},{4.15188,11.99839},{4.15392,12.02339},{ 4.1558,12.02903},{4.15724,12.03871},{4.15876,12.06694},{4.16004,12.07339},
//	{4.16172, 12.075 },{4.16408,12.08871},{ 4.1664,12.11129},{4.16828,12.10887},{4.17004,12.12258},{4.17224,12.14758},{4.17424,12.15081},{4.17612,12.16048},{ 4.1782,12.18952},{4.18052,12.19274},
//	{4.18224,12.19435},{4.18424,12.21855},{4.18652,12.2371 },{4.18848,12.2379 },{4.19036,12.24516},{4.19216,12.27823},{ 4.1938,12.27419},{4.19532,12.28548},{4.19716,12.30161},{4.19956,12.31855},
//	{4.20172,12.31452},{4.20336,12.33871},{4.20448,12.3621 },{4.20592,12.3621 },{4.20808,12.36613},{4.21032,12.39113},{4.21192,12.40565},{4.21364,12.40323},{4.21592,12.43306},{4.21808,12.44677},
//	{4.21956,12.45161},{4.22108,12.46129},{4.22304,12.4871 },{4.22524,12.47823},{4.22696,  12.5  },{ 4.2286,12.52097},{4.23072,12.52823},{4.23292,12.52742},{4.23488,12.55565},{4.23628,12.57742},
//	{4.23784,12.56774},{4.23976,12.58548},{4.24192,12.61048},{4.24388,12.61452},{4.24572,12.61774},{4.24776,12.65565},{ 4.2498,12.64919},{4.25188,12.65968},{ 4.2538,12.67339},{4.25556,12.70403},
//	{4.25736,12.69758},{4.25932,12.71694},{4.26092,12.74597},{4.26232, 12.75  },{4.26408,12.75645},{ 4.2662,12.77742},{4.26808,12.78226},{4.26968,12.78145},{4.27164,12.8129 },{ 4.274 ,12.82419},
//	{4.27644,12.82661},{4.27812,12.83871},{4.27972,12.87742},{4.28148,12.87581},{ 4.2834,12.87419},{4.28516,12.89597},{4.28664,12.91371},{4.28832,12.91048},{4.29024,12.92984},{4.29228,12.95161},
//	{4.29388,12.94194},{4.29532,12.95806},{4.29664,12.98226},{ 4.2982,12.98952},{4.30032,12.98629},{4.30256,13.01532},{ 4.3046,13.03387},{4.30656,13.03468},{4.30864,13.04435},{4.31068,13.07339},
//	{4.31252,13.06855},{4.31456,13.08629},{4.31696,13.10806},{4.31876,13.10887},{4.31976,13.11532},{4.32148,13.14113},{4.32424,13.15565},{4.32668,13.14758},{4.32824,13.16694},{4.32956,13.18871},
//	{4.33168,13.19032},{4.33372,13.19435},{ 4.335 ,13.23145},{4.33652,13.23548},{ 4.3384,13.24435},{4.34032,13.2629 },{ 4.3424,13.28952},{4.34456,13.28306},{4.34644,13.30645},{4.34808,13.33387},
//	{4.34984,13.33387},{4.35188,13.34032},{ 4.354 ,13.36048},{4.35592,13.37177},{ 4.3576,13.37016},{4.35932,13.39355},{4.36144,13.41371},{ 4.3636,13.41129},{4.36528,13.4129 },{4.36672,13.45484},
//	{4.36868,13.45081},{4.37068,13.45242},{4.37236,13.47984},{4.37424,13.49435},{4.37648,13.48468},{4.37832,13.5121 },{4.37972,13.5371 },{4.38136,13.52661},{4.38344,13.54597},{4.38552,13.57339},
//	{4.38708,13.57661},{4.38872,13.57581},{ 4.3908,13.60968},{4.39296,13.61694},{4.39496,13.62097},{4.39688,13.63629},{4.39876,13.6629 },{4.40028,13.66452},{4.40168,13.67984},{4.40352,13.70323},
//	{ 4.4054,13.70323},{4.40724,13.70726},{4.40916,13.73306},{4.41132,13.74597},{ 4.4134,13.74355},{4.41524,13.77177},{4.41732,13.78871},{ 4.4196,13.79597},{4.42132,13.79597},{4.42312,13.83548},
//	{4.42492,13.8371 },{4.42668,13.84113},{4.42856,13.85887},{4.43044,13.88065},{4.43216, 13.875 },{4.43404,13.89274},{ 4.4362,13.91935},{4.43808,13.91774},{4.43996,13.92742},{4.44184,13.95081},
//	{4.44404,13.97177},{4.44608,13.96532},{ 4.4478,13.99516},{ 4.4498,14.00887},{4.45176,   14   },{4.45348,14.01532},{ 4.4552, 14.05  },{4.45708,14.04274},{4.45896,14.05565},{4.46064,14.08226},
//	{4.46224,14.09355},{4.46424,14.09355},{4.46624,14.11371},{4.46796,14.13145},{4.46976,14.12581},{4.47152,14.14194},{4.47312,14.16694},{4.47488, 14.175 },{ 4.477 ,14.17177},{ 4.4792,14.20242},
//	{4.48088,14.20806},{ 4.4826,14.20887},{4.48456,14.22742},{ 4.4868,14.25323},{4.48852,14.25161},{  4.49 ,14.26532},{4.49188,14.29597},{4.49396,14.29839},{4.49572,14.30242},{ 4.4976,14.32177},
//	{4.50004,14.33952},{ 4.5024,14.33306},{ 4.504 ,14.36452},{4.50532,14.38871},{4.50696,14.39435},{4.50896,  14.4  },{4.51128,14.42984},{ 4.5134,14.42742},{4.51512,14.43387},{4.51716,14.45403},
//	{4.51936,14.47419},{4.52136,14.47097},{ 4.523 ,14.49597},{4.52492,14.51613},{ 4.5268,14.50887},{4.52872, 14.525 },{ 4.5304,14.55323},{4.53228,14.56532},{4.53428,14.5621 },{4.53648,14.58871},
//	{4.53848,14.60403},{4.54016,14.60726},{4.54192,14.61613},{4.54384,14.64113},{4.54584,14.63952},{4.54768,14.65323},{ 4.5494,14.67419},{4.55132,14.67984},{ 4.5534,14.68226},{ 4.555 ,14.69516},
//	{4.55672,14.72258},{4.55888,14.7121 },{4.56096,14.72258},{4.56256,14.74597},{4.56424,14.75323},{4.56648, 14.75  },{ 4.5688,14.7879 },{4.57072,14.79113},{4.57224,14.79113},{4.57376,14.81532},
//	{ 4.5758,14.84113},{4.57772,14.83629},{4.57916,14.84677},{4.58076,14.87984},{4.58304,14.87823},{ 4.585 ,14.88065},{4.58636,14.91048},{4.58832,14.92339},{ 4.5908,14.91452},{ 4.5926,14.95081},
//	{4.59428,14.96371},{4.59628,14.9629 },{4.59844,14.97258},{4.60016,15.00565},{4.60172,15.00645},{4.60356,15.01371},{4.60552,15.04113},{4.60748, 15.05  },{4.60916, 15.05  },{4.61096,15.07016},
//	{4.61292,15.09032},{4.61448,15.07984},{4.61636,15.10403},{4.61872,15.12177},{ 4.6208,15.12984},{4.62228,15.13065},{4.62392,15.15887},{4.62588,15.16855},{4.62784,15.17339},{4.62968,15.18226},
//	{4.63156,15.2129 },{ 4.6334,15.20806},{4.63524,15.22177},{4.63744,15.24919}
//};

////////////////////////////////////////////////////////////////////////////////////
//...\E0\EF\EF\F0\EE\EA\F1\E8\EC\E0\F6\E8\FF \EF\EE\F2\E5\ED\F6\E8\E0\EB\EE\EC \CC\F3\ED\E8-\D0\E8\E2\EB\E8\ED\E0 (\E2\F2\EE\F0\EE\E3\EE, \F2\F0\E5\F2\FC\E5\E3\EE, \F7\E5\F2\E2\E5\F0\F2\EE\E3\EE \EF\EE\F0\FF\E4\EA\E0);
	int N_matr = 4;
	double h1 = 0., h2 = 0., h3 = 0., h4 = 0., sigma = 0., F1, F2, F3, F4, C1, C2, C3, C4, eps, delta, lambda,
		matr[4][4] = {
			{ 0., 0., 0., 0.},
			{ 0., 0., 0., 0.},
			{ 0., 0., 0., 0.},
			{ 0., 0., 0., 0.}
	};

//////////////////////////////////////////////////////////
//...\F4\EE\F0\EC\E8\F0\EE\E2\E0\ED\E8\E5 \EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2\EE\E2 \EA\E2\E0\E4\F0\E0\F2\E8\F7\ED\EE\E3\EE \F4\F3\ED\EA\F6\E8\EE\ED\E0\EB\E0;
	for (int i = 0; i < N_muni; i++) {
		//lambda = muni[i][0]; //...\E8\F1\F5\EE\E4\ED\EE\E5 - \F3\E4\EB\E8\ED\E5\ED\E8\E5;
		lambda = 1.+muni[i][0]/100.; //...\E8\F1\F5\EE\E4\ED\EE\E5 - \E4\E5\F4\EE\F0\EC\E0\F6\E8\FF \E2 %;
		sigma += sqr(muni[i][1]*lambda);
		F1 = 2.*(sqr(lambda)-1./lambda);
		F2 = 2.*(lambda-1./sqr(lambda));
		F3 = 2.*(sqr(lambda)+2./lambda-3.)*F1;
		F4 = 2.*(1./sqr(lambda)+2.*lambda-3.)*F2;

		matr[0][0] += F1*F1;
		matr[0][1] += F1*F2;
		matr[0][2] += F1*F3;
		matr[0][3] += F1*F4;
		h1 += F1*muni[i][1]*lambda;

		matr[1][0] += F2*F1;
		matr[1][1] += F2*F2;
		matr[1][2] += F2*F3;
		matr[1][3] += F2*F4;
		h2 += F2*muni[i][1]*lambda;

		matr[2][0] += F3*F1;
		matr[2][1] += F3*F2;
		matr[2][2] += F3*F3;
		matr[2][3] += F3*F4;
		h3 += F3*muni[i][1]*lambda;

		matr[3][0] += F4*F1;
		matr[3][1] += F4*F2;
		matr[3][2] += F4*F3;
		matr[3][3] += F4*F4;
		h4 += F4*muni[i][1]*lambda;
	}

////////////////////////////////////////////////////////
//...\E2\FB\F7\E8\F1\EB\E5\ED\E8\E5 \EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2\EE\E2 \EA\E2\E0\E4\F0\E0\F2\E8\F7\ED\EE\E3\EE \F4\F3\ED\EA\F6\E8\EE\ED\E0\EB\E0;
	int ii[4] = {0, 0, 0, 0}, kk[4], ll[4], k, l, k0, l0;
	for (int  i = 0; i < N_matr; i++) {
		double f = 0.;
///////////////////////////////////////
//...look for position maximal element;
		for (k = 0; k < N_matr; k++)
			if (ii[k] != 1) 
				for (l = 0; l < N_matr; l++) 
					if (! ii[l]) {
						if (fabs(matr[k][l]) >= f) f = fabs(matr[k0 = k][l0 = l]); 
					}
					else if (ii[l] > 1) {
						break;
					}
		++(ii[l0]);
///////////////////////////////////////////////////////////
//...swapping row for diagonal position of maximal element;
		if (k0 != l0) 
			for (l = 0; l < N_matr; l++) {
				f = matr[k0][l]; matr[k0][l] = matr[l0][l]; matr[l0][l] = f; 
			}
		kk[i] = k0; 
		ll[i] = l0;
		if (matr[l0][l0] == 0.) {
			break;
		}
////////////////////////////////
//...diagonal row normalization;
		double finv = 1./matr[l0][l0]; matr[l0][l0] = 1.;
		for (l = 0; l < N_matr; l++) matr[l0][l] *= finv;
/////////////////////////////////
//...elimination all outher rows;
		for (k = 0; k < N_matr; k++)
			if ( k != l0) {
				finv = matr[k][l0]; matr[k][l0] = 0.;
				for (l = 0; l < 4; l++) matr[k][l] -= matr[l0][l]*finv;
			}
//////////////////////////////////////////////////////////////////////////////////
////...reverse sorting of columns of inverse matrix and memory release and return;
	for (l = N_matr-1; l >= 0; l--)
		if (kk[l] != ll[l])
			for (k = 0; k < N_matr; k++) {
				double f = matr[k][kk[l]]; matr[k][kk[l]] = matr[k][ll[l]]; matr[k][ll[l]] = f;
			}
	}
	//h3 = h4 = 0.;
	C1 = matr[0][0]*h1+matr[0][1]*h2+matr[0][2]*h3+matr[0][3]*h4;
	C2 = matr[1][0]*h1+matr[1][1]*h2+matr[1][2]*h3+matr[1][3]*h4;
	C3 = matr[2][0]*h1+matr[2][1]*h2+matr[2][2]*h3+matr[2][3]*h4;
	C4 = matr[3][0]*h1+matr[3][1]*h2+matr[3][2]*h3+matr[3][3]*h4;
	eps = sigma-h1*C1-h2*C2-h3*C3-h4*C4;
	eps = sqrt(eps);
	delta = eps/sqrt(sigma);

////////////////////////
//...\EF\E5\F7\E0\F2\E0\E5\EC \F0\E5\E7\F3\EB\FC\F2\E0\F2;
	FILE *  result = fopen("Muni-Rivlin_micro4.dat", "w");
	fprintf(result, " C1 = %g\n C2 = %g\n C3 = %g\n C4 = %g\n delta = %g\n ", C1, C2, C3, C4, delta);
	fclose (result);
}
#endif

#ifdef INP_CONVERTOR
{
	//char * name = "c:\\SIMULIA\\Job\\Abaqus\\2014\\Aminjevskoje_2014\\models\\Constru\\copy_mesh\\Aminjevskoje.inp";
	//int ID_elements[] = {8, -51, -57, -58, -59, -60, -61, -62, -63}, ID_element_part;
	char * name = "c:\\SIMULIA\\Job\\Abaqus\\2014\\Aminjevskoje_2014\\models\\Constru\\copy_mesh_prev_scheme\\Aminjevskoje_IGE_corr.inp";
	int ID_elements[] = {5, -4, -45, -50, -54, -56}, ID_element_part;
	//char * name = "c:\\SIMULIA\\Job\\Abaqus\\2014\\Aminjevskoje_2014\\models\\Constru\\copy_mesh_prev_scheme\\Aminjevskoje_step7.inp";
	//int ID_elements[] = {2, -4, -46}, ID_element_part;



//////////////////////////
//...\E8\ED\E8\F6\E8\E0\EB\E8\E7\E0\F6\E8\FF \E7\E0\E4\E0\F7\E8;
	CGrid_el * nd = new CGrid_el;	

///////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	if (nd) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		nd->nodes_inp(name);
		Message("Finish!");
	}

////////////////////////////////////
//...\E4\EE\E1\E0\E2\EB\E5\ED\E8\E5 \E2 \EC\EE\E4\E5\EB\FC \ED\EE\E2\FB\F5 \F3\E7\EB\EE\E2;
//	int  ID_node_set, ID_element_set;
//	Inp_nodes_add(name, nd, ID_node_set = -13, ID_element_set = -14);

/////////////////////////////////////////
//...\E4\EE\E1\E0\E2\EB\E5\ED\E8\E5 \E2 \EC\EE\E4\E5\EB\FC \ED\EE\E2\FB\F5 \FD\EB\E5\EC\E5\ED\F2\EE\E2;
	Inp_elements_add(name, nd, ID_elements, ID_element_part = 1);

	delete nd;
}
#endif
#ifdef UWay_CONVERTOR
{
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\Models_inp\\Testing\\Variant01 - test_1, small\\Test_1.inp";
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\Models_inp\\Testing\\Test_1.inp";
	char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\Models_inp\\Testing\\Test_2.inp";
	int ID_part;

//////////////////////////
//...\E8\ED\E8\F6\E8\E0\EB\E8\E7\E0\F6\E8\FF \E7\E0\E4\E0\F7\E8;
	CGrid_el * nd = new CGrid_el;	

///////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	if (nd) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		nd->nodes_inp(name);
		Message("Finish!");
	}

///////////////////////////////////////////////////////////
//...\EA\EE\ED\E2\E5\F0\F2\E0\F6\E8\FF \E3\E5\EE\EC\E5\F2\F0\E8\E8 \E8 \E2\F1\E5\E9 \E7\E0\E4\E0\F7\E8 \E8\E7 \E2\F5\EE\E4\ED\EE\E3\EE \F4\E0\E9\EB\E0;
	Convert3D_gmt(name, nd, ID_part = 1);
	Convert3D_prb(name, nd, ID_part);

	delete nd;
}
#endif
#ifdef C3D_CONVERTOR_prev
{
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\sample01\\Eb015pi.c3d";
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\2ride1.c3d";//2ride2.c3d,2ride3.c3d
	char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\ride3.c3d";//ride2.c3d,ride3.c3d
	
	unsigned short num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, channel_num = 1, marker_num = 1; 
	unsigned char ** mlabels = NULL, ** alabels = NULL, * res_marker = NULL;
	float scale_factor, video_rate, gscale, * ascale = NULL;
	int	* zero_off = NULL, i = 0, j = 0;
	short * val_channel = NULL, ** val_marker = NULL, ** analog = NULL;
	float ** x = NULL, ** y = NULL, ** z = NULL;
	char  ** residual = NULL, ** num_cam = NULL;

/////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \F0\E0\E7\E4\E5\EB\EE\E2 \E8\F1\F5\EE\E4\ED\EE\E3\EE \F4\E0\E9\EB\E0;
	FILE * infile = fopen(name, "r+b");
	Read_C3D_Header(&num_markers, &num_channels, &first_field, &last_field, &scale_factor, &start_record_num, &frames_per_field, &video_rate, infile);
	Read_C3D_Parameters (mlabels, alabels, &gscale, ascale, zero_off, infile);

	val_channel = (short *)new_struct(frames_per_field*(last_field-first_field+1)*sizeof(short));
	if (num_channels) {
		Read_C3D_Channel(channel_num+0, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_channel, infile);
		Read_C3D_Channel(channel_num+1, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_channel, infile);
		Read_C3D_Channel(channel_num+2, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_channel, infile);
	}	
	set_matrix(val_marker, last_field-first_field+1, 3);
	res_marker = (unsigned char *)new_struct((last_field-first_field+1)*sizeof(char));
	if (num_markers) {
		Read_C3D_Marker(marker_num+0, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_marker, res_marker, infile);
		Read_C3D_Marker(marker_num+1, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_marker, res_marker, infile);
		Read_C3D_Marker(marker_num+2, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_marker, res_marker, infile);
	}
	set_matrix(x, num_markers, last_field-first_field+1);
	set_matrix(y, num_markers, last_field-first_field+1);
	set_matrix(z, num_markers, last_field-first_field+1);
	set_matrix(residual, num_markers, last_field-first_field+1);
	set_matrix(num_cam,  num_markers, last_field-first_field+1);
	set_matrix(analog, num_channels, (last_field-first_field+1)*frames_per_field);
	Read_C3D_Data_float(num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field,	x, y, z, residual, num_cam, analog, infile);
	fclose(infile); 

	delete_struct(mlabels);
	delete_struct(alabels);
	delete_struct(zero_off);
	delete_struct(val_channel);
	delete_struct(val_marker);
	delete_struct(res_marker);
	delete_struct(x);
	delete_struct(y);
	delete_struct(z);
	delete_struct(residual);
	delete_struct(num_cam);
	delete_struct(analog);
}
#endif
#ifdef C3D_CONVERTOR
{
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\rides\\2ride1.c3d";//2ride2.c3d,2ride3.c3d
	char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\rides\\ride6.c3d";//ride2.c3d,ride3.c3d
	
	unsigned short num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field; 
	short ** analog = NULL;
	char  ** residual = NULL, ** num_cam = NULL, marker[2000];
	float ** x = NULL, ** y = NULL, ** z = NULL, scale_factor, video_rate;
	double time, P[3]; int k = 0, j;

/////////////////////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \F2\F0\E0\E5\EA\F2\EE\F0\E8\E9 \E8\E7 \E8\F1\F5\EE\E4\ED\EE\E3\EE \F4\E0\E9\EB\E0 \E8 \E7\E0\EF\E8\F1\FC \E8\F5 \E2 \F4\EE\F0\EC\E0\F2\E5 iges;
	FILE * infile = fopen(name, "r+b");
	Read_C3D_Header(&num_markers, &num_channels, &first_field, &last_field, &scale_factor, &start_record_num, &frames_per_field, &video_rate, infile);

	set_matrix(x, num_markers, last_field-first_field+1);
	set_matrix(y, num_markers, last_field-first_field+1);
	set_matrix(z, num_markers, last_field-first_field+1);
	set_matrix(residual, num_markers, last_field-first_field+1);
	set_matrix(num_cam,  num_markers, last_field-first_field+1);
	set_matrix(analog, num_channels, (last_field-first_field+1)*frames_per_field);
	Read_C3D_Data_float(num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field,	x, y, z, residual, num_cam, analog, infile);
	fclose(infile); 

////////////////////////////////////////////////////////////////////////////////////
//...\EF\E8\F8\E5\EC \E2\F1\E5 \EC\E0\F0\EA\E5\F0\FB \E2 CGrid \F1\EE \F1\E2\EE\E8\EC\E8 \ED\EE\EC\E5\F0\E0\EC\E8 \E8 \EA\EE\ED\E2\E5\F0\F2\E8\F0\F3\E5\EC \E2\F1\E5 \EC\E0\F0\EA\E5\F0\FB \E2 iges;
	CGrid_el * marker_nd = new CGrid_el;
	FILE		* TST = fopen("Ride6.dat", "w");

	fprintf(TST, "   hit            X              Y              Z              time\n");
	for (k = 0; k < num_markers; k++) if ( k != -1)
	for (j = 0, time = 0.; j <= last_field-first_field; j++, time += 0.003333333333333333333333333) {
		P[0] = x[k][j]*0.001;
		P[1] = y[k][j]*0.001;
		P[2] = z[k][j]*0.001;
		if (sqr(P[0])+sqr(P[1])+sqr(P[2]) > EE) {
			marker_nd->add_new_point(P[0], P[1], P[2], 0., 0., 0.); marker_nd->hit[marker_nd->N-1] = k;
			fprintf(TST, "%7i%15g%15g%15g%15g\n", k, marker_nd->X[j], marker_nd->Y[j], marker_nd->Z[j], time);
		}
	}
	marker_igs("Ride6.igs",  marker_nd);
	fclose(TST);

////////////////////////////////////////////
//...\EA\EE\EE\F0\E4\E8\ED\E0\F2\FB \EC\E0\F0\EA\E5\F0\EE\E2 \E2 \ED\E0\F7\E0\EB\FC\ED\FB\E9 \EC\EE\EC\E5\ED\F2;
	TST = fopen("marker_num_t90.dat", "w");

	fprintf(TST, "   hit            X              Y              Z\n");
	for (j = 90, k = 0; k < num_markers; k++) {
		P[0] = x[k][j]*0.001;
		P[1] = y[k][j]*0.001;
		P[2] = z[k][j]*0.001;
		if (sqr(P[0])+sqr(P[1])+sqr(P[2]) > EE) {
			fprintf(TST, "%7i%15g%15g%15g\n", k, P[0], P[1], P[2]);
		}
	}
	fclose(TST);

//////////////////////////////////////
//...\EF\E8\F8\E5\EC \E2\F1\E5 \EC\E0\F0\EA\E5\F0\FB \EF\EE \EE\F2\E4\E5\EB\FC\ED\EE\F1\F2\E8;
	//marker_nd->add_buffer(marker_nd->N);
	//for (k = 0; k < num_markers; k++) {
	//	for (j = 0; j <= last_field-first_field; j++) {
	//		P[0] = x[k][j]*0.001;
	//		P[1] = y[k][j]*0.001;
	//		P[2] = z[k][j]*0.001;
	//		if (sqr(P[0])+sqr(P[1])+sqr(P[2]) > EE)
	//			marker_nd->add_new_point(P[0], P[1], P[2], 0., 0., 0.);
	//	}
	//	sprintf  (marker, "marker_%i,igs", k);
	//	track_igs(marker,  marker_nd); marker_nd->add_buffer(marker_nd->N);
	//}
	delete_struct(x);
	delete_struct(y);
	delete_struct(z);
	delete_struct(residual);
	delete_struct(num_cam);
	delete_struct(analog);
	delete_struct(analog);
	delete marker_nd; 
}
#endif
#ifdef TEST_CCELLS
{
	char * name = "./Models_inp/Box3D_sph/Box3D_sph112.inp";

////////////////////////////////////////////
//...\E7\E0\F7\E8\F2\FB\E2\E0\E5\EC \E3\E5\EE\EC\E5\F2\F0\E8\FE \E8\E7 \E2\F5\EE\E4\ED\EE\E3\EE \F4\E0\E9\EB\E0;
	CGrid stru;
	stru.nodes_in(name);

//////////////////////////////////////
//...\EF\EE\F0\EE\E6\E4\E0\E5\EC \E3\E5\EE\EC\E5\F2\F0\E8\F7\E5\F1\EA\E8\E9 \FD\EB\E5\EC\E5\ED\F2;
	CCeBasic * ce = new CCeBasic, * f0 = new CCeBasic;
   //ce->get_nd_bar_directly(& stru, 1);
	//ce->get_sheet(2., 1.);
   //ce->get_ring_segment(0., M_PI*.75, 1., 2.);
   //ce->get_sph_segment(1., 0, M_PI*.75, M_PI*.5, M_PI*.75);
   //ce->get_cyl_segment(1., 0., M_PI*.75, 1., 3.);
   //ce->get_cone_segment(M_PI/12., 0., 8./3.*M_PI*.75, 0., 3.);
   //ce->get_torus_segment(3., 1., -M_PI*.75, M_PI*.75, 0., M_PI*.75);
	//ce->get_sheet_intrusion(2., 1., 0.3);
	//ce->get_sph_intrusion(1.3, 1.);
	ce->get_blend_cyl_segment(2., 1., 3.);
	//f0->get_sheet(2., 1.); double pp[3] = {3., 0., 0.};
	//f0->cells_iso(pp);
	//f0->get_ugolok_cell(2., 2., 1., 1., 0.3, 0.15, 60.);
	//ce->get_beam(f0, 2.);
	ce->segms_id();

	//double pp[] = {1., 2., 0.};
	//ce->cells_iso(pp, M_PI/6., M_PI/3.);

/////////////////////////////////////
//...\EF\E5\F7\E0\F2\E0\E5\EC \E3\E5\EE\EC\E5\F2\F0\E8\F7\E5\F1\EA\E8\E9 \FD\EB\E5\EC\E5\ED\F2;
	//ce->bar_exc(1);
	ce->cells_out("CCeBasic");

///////////////////////////////////////////////
//...\F1\F2\F0\EE\E8\EC \EF\EE\E2\E5\F0\F5\ED\EE\F1\F2\F0\F3\FE \F1\E5\F2\EA\F3 \E8\EB\E8 \EA\E2\E0\E4\F0\E0\F2\F3\F0\F3;
	CGrid_QG *  nd = new CGrid_QG; 
	CGrid 	* bnd = new CGrid;
	int N_elem = 20, N_max = 3;

	if (ce->mp) {
		ce->segms_QG(nd, N_elem, N_max);
		bnd->grid_add(nd);
	}
	else
	for (int N_arcs = ce->arcs_number(), i = 0; i < N_arcs; i++) {
		ce->ce[i]->segms_QG(nd, N_elem, N_max);
		bnd->grid_add(nd);
	}
	bnd->TestGrid("grid_X.bln", 0.001, 10., 20., 30., AXIS_X, OK_STATE);
	bnd->TestGrid("grid_Y.bln", 0.0003, 0., 0., 0., AXIS_Y);
	bnd->TestGrid("grid_Z.bln", 0.0003, 0., 0., 0., AXIS_Z);

	delete_cells(ce);
	delete  nd;
	delete bnd;
}
#endif
#ifdef TEST_SHAPES
{
	CShapeMixer<double> * sp = new CShapeMixer<double>;
	sp->add_shape(CreateShapeD(MP3D_SPHERE_SHAPE));
	//sp->add_shape(CreateShapeD(SK3D_EXPP_SHAPE));
	//sp->add_shape(CreateShapeD(SK3D_EXPP_SHAPE, 1));
 
	double kk = 1.2, R0 = 1., eps0 = 5e-5, eps1 = 5e-9, A, B, C, L, f, fo,
			 pp[14], * p_cpy, * p_cpy1, * p_cpy2, * p_cpy3, * p_cpy4, mp[6] = {0., 0., 0., 0., 0., 0.};
	int N = 5, m = 1, dim = 1;

	sp->init1(N, m, dim);
	sp->init_potential();
	sp->set_shape(R0, kk);
	sp->set_local(mp);

/////////////////////////////////////////
//...\E2\E8\E7\F3\E0\EB\E8\E7\E0\F6\E8\FF \EF\EE\E2\E5\F0\F5\ED\EE\F1\F2\E8 \EC\F3\EB\FC\F2\E8\EF\EE\EB\FF;
	double bound[5] = {-1.5, 1.5, -1.5, 1.5, 0.};
	//double bound[5] = {0., M_PI, -M_PI, M_PI, kk};
	sp->A[0][4] = 0.26788;
	sp->GetSurferFormat("shapes_out", bound, AXIS_Y);

//////////////////////////////////////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E4\E8\F4\F4\E5\F0\E5\ED\F6\E8\E0\EB\FC\ED\FB\F5 \E8 \E8\ED\F2\E5\E3\F0\E0\EB\FC\ED\FB\F5 \F1\EE\EE\F2\ED\EE\F8\E5\ED\E8\E9;
	FILE * TST = fopen("multipoles_test", "w");
	p_cpy  = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy1 = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy2 = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy3 = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy4 = (double *)new_struct(sp->NN*sizeof(double));

	L = 0.1; 
	A = 1.2; 
	B = 1.5; 
	C = 1.6;
	for (int k = 0; k < 1/*4*/; k++)
	for (int i = 0; i < 1/*4*/; i++)
	for (int j = 0; j < 1/*4*/; j++) {
		fprintf(TST, "test_%i%i%i : ", k, i, j);
		pp[0]  = pp[7] = A + L*k;
		pp[1]  = pp[8] = B + L*i;
		pp[2]  = pp[9] = C + L*j;
		pp[3]  = 1.;
		pp[4]  = 2.;
		pp[5]  = 3.;
		pp[10] = (pp[3] *= (f = 1./sqrt(pp[3]*pp[3]+pp[4]*pp[4]+pp[5]*pp[5])));
		pp[11] = (pp[4] *=  f);
		pp[12] = (pp[5] *=  f);
		pp[13] =  pp[6] = 0.1;//...\E7\E0\E4\E0\ED\E8\E5 \E2\F0\E5\EC\E5\ED\E8;
		fprintf(TST, "X = %g, Y = %g, Z = %g\n",  pp[0], pp[1], pp[2]);
		fprintf(TST, "normal = (%g, %g, %g)\n\n", pp[3], pp[4], pp[5]);
	
////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E3\F0\E0\E4\E8\E5\ED\F2\E0;
//*		
		fprintf(TST, "\E3\F0\E0\E4\E8\E5\ED\F2:\n");
		sp->parametrization_hess(pp);
		sp->deriv_N();
		sp->cpy(sp->p_cpy, p_cpy);

		pp[7] += pp[3]*eps1;
		pp[8] += pp[4]*eps1;
		pp[9] += pp[5]*eps1;
		sp->parametrization_hess(pp+7);
		pp[7] -= pp[3]*eps1;
		pp[8] -= pp[4]*eps1;
		pp[9] -= pp[5]*eps1;

		for (int l = 0; l < sp->NN; l++) {
			f = (sp->p_cpy[l]-p_cpy[l])/eps1;
			if (TST) fprintf(TST, "Df-deriv = %g  Df[%d] = %g\n", sp->deriv[l]-f, l, sp->deriv[l]);

  			if (fabs(sp->deriv[l]-f) > 100.*eps1)
			printf("Df-deriv = %g  l = %d\n", sp->deriv[l]-f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E2\F2\EE\F0\EE\E9 \EF\F0\EE\E8\E7\E2\EE\E4\ED\EE\E9;
//*		
		fprintf(TST, "Dxx:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_xx(p_cpy, 1.);

		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy3, sp->p_cpy, 0., 1.); 
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		sp->admittance(p_cpy1, p_cpy3, 1., 1.);
		sp->admittance(p_cpy1, NULL, 1./eps0, 0.);
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., 1.);
		sp->admittance(p_cpy2, p_cpy3, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);
		pp[7] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dxx(f)-deriv = %g  Dxx(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dxx(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E2\F2\EE\F0\EE\E9 \EF\F0\EE\E8\E7\E2\EE\E4\ED\EE\E9;
//*		
		fprintf(TST, "Dyy:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_yy(p_cpy, 1.);

		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy3, sp->p_cpy, 0., 1.); 
		pp[8] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		sp->admittance(p_cpy1, p_cpy3, 1., 1.);
		sp->admittance(p_cpy1, NULL, 1./eps0, 0.);
		pp[8] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., 1.);
		sp->admittance(p_cpy2, p_cpy3, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);
		pp[8] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dyy(f)-deriv = %g  Dyy(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dyy(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E2\F2\EE\F0\EE\E9 \EF\F0\EE\E8\E7\E2\EE\E4\ED\EE\E9;
//*		
		fprintf(TST, "Dzz:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_zz(p_cpy, 1.);

		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy3, sp->p_cpy, 0., 1.); 
		pp[9] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		sp->admittance(p_cpy1, p_cpy3, 1., 1.);
		sp->admittance(p_cpy1, NULL, 1./eps0, 0.);
		pp[9] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., 1.);
		sp->admittance(p_cpy2, p_cpy3, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);
		pp[9] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dzz(f)-deriv = %g  Dzz(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dzz(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E2\F2\EE\F0\EE\E9 \EF\F0\EE\E8\E7\E2\EE\E4\ED\EE\E9;
//*		
		fprintf(TST, "Dxy:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_xy(p_cpy, 1.);

		sp->cpy_xy();//...\F1\EC\E5\F8\E0\ED\ED\E0\FF \EF\F0\EE\E8\E7\E2\EE\E4\ED\E0\FF; 
		sp->admittance(sp->deriv, NULL, 0., 0.);	
		sp->deriv_Z(sp->deriv); 
		sp->cpy_xy(); 

		pp[8] -= eps0;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy1, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[8] += eps0*2.;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[8] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dxy(f)-deriv = %g  Dxy(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dxy(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E2\F2\EE\F0\EE\E9 \EF\F0\EE\E8\E7\E2\EE\E4\ED\EE\E9;
//*		
		fprintf(TST, "Dxz:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_xz(p_cpy, 1.);

		pp[9] -= eps0;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy1, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[9] += eps0*2.;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[9] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dxz(f)-deriv = %g  Dxz(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dxz(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...\EF\F0\EE\E2\E5\F0\EA\E0 \E2\F2\EE\F0\EE\E9 \EF\F0\EE\E8\E7\E2\EE\E4\ED\EE\E9;
//*		
		fprintf(TST, "Dyz:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_yz(p_cpy, 1.);

		sp->cpy_yz();//...\F1\EC\E5\F8\E0\ED\ED\E0\FF \EF\F0\EE\E8\E7\E2\EE\E4\ED\E0\FF; 
		sp->admittance(sp->deriv, NULL, 0., 0.);	
		sp->deriv_X(sp->deriv); 
		sp->cpy_yz(); 

		pp[9] -= eps0;
		pp[8] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		pp[8] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy1, NULL, .5/eps0, 0.);
		pp[8] -= eps0;
		pp[9] += eps0*2.;
		pp[8] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., -1.); 
		pp[8] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);
		pp[8] -= eps0;
		pp[9] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dyz(f)-deriv = %g  Dyz(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dyz(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/	
	
	}
	if (TST) fclose(TST);

	delete_struct(p_cpy);
	delete_struct(p_cpy1);
	delete_struct(p_cpy2);
	delete_struct(p_cpy3);
	delete_struct(p_cpy4);
 
	delete_shapes(sp);
}
#endif
#ifdef TEST_DRAFT_ALL
{
	//const char * name = "../Exe/Box2d_homog/heat_clayer488.nas";
	//const char * name = "../Exe/Box2d_homog/sph_025_16.nas";
	//const char * name = "../Exe/Box2d_homog/ell_80_20_i_1980.nas";
	const char * name = "../Exe/Box2d_homog/ell_80_20q7.nas";

//////////////////////////
//...
	CDraft<double> * sm = CreateDraft(LAME2D_DRAFT);
	sm->set_mpls(PackInts(2, 2)); //...;
	sm->set_quad(PackInts(8, 8)); //...;
	sm->set_normaliz(0.92);			  //...;
	sm->set_lagrange(1e4);			  //...; 
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGULARIZATION2/*PRINT_MODE*//*FULLY_MODE*/);

//////////////////////
//...;
	//double K1 = 1.7,	//... (matrtix);
	//		 K2 = 30.,	//... (inclusion);
	//		 K3 = 3.;	//...;
	//sm->set_fasa_hmg(K1, K2, K3);
	double nj1 = 0.33, //...; 
			 nj2 = 0.20, //...; 
			 nj3 = 0.30, //...; 
			 E1  = 18.,  //...GPa;
			 E2  = 380., //...GPa; 
			 E3  = 57.5; 
	sm->set_fasa_hmg(nj1, nj2, nj3, E1/(1.+nj1)*.5, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5);

///////////////////////////////////////////////////////
//...;
	int id_reading = 0, m;
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	if (sm) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (int j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	double par[6];	sm->SetGeomBounding(par);
	if (! id_reading) {
		X0 = (par[0]+par[1])*.5;
		Y0 = (par[2]+par[3])*.5;
		ell_X = 0.80;
		ell_Y = 0.20;
		rot_Z = 0.;
	}
	if (ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (m = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[m] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

////////////////////
//...;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 700;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
		//AbstractSolver		(& pBCM, 
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<double>, Blocks_Partitioning<double>, 
								Blocks_Sparsity<double>, Blocks_Row<double>, 
								Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
		sm->shapes_init(OK_STATE); 
	}
#endif	

//////////////////////////////////////////////////////////////////
//...;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
//////////////////
//..visualization;
		res = system("mkdir var3_results");
		//res = system("del *.grd");
		int id_visual = 1;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			sm->BlockActivate(NULL_STATE);

			int NX = 200, NY = 200;
			for (int i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (int j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			int hit = ERR_STATE;
			for (int i = 0; i < nd->N;  i++)
			for (int j = 0; j < nd->N1; j++) {
				sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);

				nd->hit[i+j*nd->N] = hit;
			}
			//sm->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
			//sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);
			sm->GetSurferFormat("var3_results/bb", nd,       ERR_VALUE, 0);
			sm->GetSurferFormat("var3_results/rx", nd,     DISPL_VALUE, 0);
			sm->GetSurferFormat("var3_results/tx", nd,  STRESS_X_VALUE, 0);

			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_VISCO
{
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_84.inp";
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_172.inp";
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_184.inp";
	char * name_ini = "./Models_inp/Box2D_sph/sph_009_496.inp";

	//char * name_ini = "./Box2d_homog/sph_025_16.nas";

//////////////////////////
//...;
	CDraft<complex> * sm = CreateDraftC(VISCO2D_GRAD_DRAFT);
	sm->set_mpls(PackInts(1, 1)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(4, 2)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);			  //...\ED\EE\F0\EC\E8\F0\F3\FE\F9\E8\E9 \EC\ED\EE\E6\E8\F2\E5\EB\FC;
	sm->set_lagrange(1e4);			  //...\EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2 \CB\E0\E3\F0\E0\ED\E6\E0; 
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);

//////////////////////
//...\EF\E0\F0\E0\EC\E5\F2\F0\FB \E7\E0\E4\E0\F7\E8;
	double E1 = 6.0,	//...\EB\E5\E4\FF\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0(GPa); 
			 E2 = 50.,	//...\EC\E8\ED\E5\F0\E0\EB\FC\ED\E0\FF \F7\E0\F1\F2\E8\F6\E0 (\EF\E5\F1\EE\EA, GPa); 
			 nju1 = 0.3,//...\EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.3,//...\E2\EA\EB\FE\F7\E5\ED\E8\E5; 
			 G1   = E1/(1.+nju1)*.5,
			 G2   = E2/(1.+nju2)*.5,
			 K1   = E1/(3.-6.*nju1),
			 K2   = E2/(3.-6.*nju2),
			 AA   = E1*0.0, //...\ED\EE\F0\EC\E0\EB\FC\ED\FB\E9  \E0\E4\E3\E5\E7\E8\EE\ED\ED\FB\E9 \EC\EE\E4\F3\EB\FC (GPa);
			 BB   = G1*0.0, //...\EA\E0\F1\E0\F2\E5\EB\FC\ED\FB\E9 \E0\E4\E3\E5\E7\E8\EE\ED\ED\FB\E9 \EC\EE\E4\F3\EB\FC (GPa);
			 d0   = 0.,   //...\E4\EE\EB\FF \E0\E4\E3\E5\E7\E8\EE\ED\ED\EE\E9 \EA\EE\EC\EF\EB\E5\EA\F1\ED\EE\F1\F2\E8;
			 l1   = 0.06, //...\EA\E0\F1\E0\F2\E5\EB\FC\ED\FB\E9 \EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0;
			 l2   = 0.06, //...\E4\EE\EF\EE\EB\ED\E8\F2\E5\EB\FC\ED\FB\E9 \EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0;
			 d1   = 0.0, //...\E4\EE\EB\FF \EF\EE\F2\E5\F0\FC (\EA\EE\EC\EF\EB\E5\EA\F1\ED\EE\F1\F2\FC) \E2 \EC\E0\F2\F0\E8\F6\E5;
			 d2   = 0.;   //...\E4\EE\EB\FF \EF\EE\F2\E5\F0\FC (\EA\EE\EC\EF\EB\E5\EA\F1\ED\EE\F1\F2\FC) \E2\EE \E2\EA\EB\FE\F7\E5\ED\E8\E8;
	sm->set_fasa_hmg(K1, K2, G1, G2, l1, l2, d1, d2, AA, BB, d0);

///////////////////////////////////////////////////////
//...    \F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	int  id_reading = 0;
	if (sm) {
		sprintf(buf, "Loading model from file '%s'", name_ini);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name_ini);
      sm->bar_condit_in(name_ini);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (int j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		if (ell_X != 0. && ell_Y != 0.) {
			CCells * ce = new(CCells); int l;
			ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
			ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
			ce->mp[1] = X0;
			ce->mp[2] = Y0;
			ce->mp[4] = rot_Z/180.*M_PI;
			ce->mp[7] = ell_X;
			ce->mp[8] = ell_Y;
			ce->mp[l] = (CMap)NULL_CELL;
			sm->bar = new(CCells);
			sm->bar->bar_add(ce);
		}
		Message("Finish!");
	}

////////////////////
//...\F0\E5\F8\E5\ED\E8\E5 \E7\E0\E4\E0\F7\E8;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		delete sm;
		goto err;
	}

//////////////////
//..visualization;
	CGrid * nd = CreateNodes();
	{
		double par[6], E0, nu, mu, C0, lm, ff_vol; sm->SetGeomBounding(par);
		complex K[12]; memset(K, 0, 12*sizeof(complex));
		sm->GetRigidy(K);

		C0 = to_double((K[0]-2.*K[2]*K[5]/(K[5]+K[3]))/(K[3]-2.*K[5]*K[5]/(K[5]+K[3])));
		lm = to_double((K[2]-C0*K[5])/(K[5]+K[3]));
		E0 = to_double((C0-lm)*(C0+2.*lm)/(C0+lm));
		nu = to_double(lm/(C0+lm));
		mu = to_double(K[7]/(K[10]*2.));
		ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

		FILE  * TST = fopen("box2D_ell_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  E0 = %g  mu = %g  nu = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol, E0, mu, nu, ell_X, ell_Y, rot_Z, E1, E2, nju1, nju2);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			nd->zero_grid(); 

			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (int i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (int j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			int hit = ERR_STATE;
			for (int i = 0; i < nd->N;  i++)
			for (int j = 0; j < nd->N1; j++) {
				sm->Poly_struc_in2D(hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			system("del *.grd");

			sm->GetSurferFormat("bb", nd,       ERR_VALUE, 0);
			sm->GetSurferFormat("rx", nd,     DISPL_VALUE, 0);
			sm->GetSurferFormat("ry", nd,     DISPL_VALUE, 1);
			sm->GetSurferFormat("tx", nd,  STRESS_X_VALUE, 0);
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef TEST_DRAFT_HYDRO
{
	//char * name = "./Parametric/Unit3d_008.nas";
	//char * name = "./Models_inp/Box3D_sph/Box3D_sph112.inp";

	//char * name = "./Models_nas/Bench/hydro/bench_02_450.nas";
	//char * name = "./Models_nas/Bench/hydro/zet_02_600.nas";
	
	//char * name = "./Seepage/Flow_R30_octa_M44.inp";
	char * name = "./Seepage/Flow_R30_full_M288.inp";
	//char * name = "./Seepage/Flow_R30_full_M432.inp";
	//char * name = "./Seepage/Filtr_R65_full_M96.inp";
	//char * name = "./Seepage/Filtr_R65_full_M432.inp";

	double par[6], k0 = 3., L = 0.5, rad = 0.3, layer = 0.0, eps_in = 1e-2;
	int i, j, k, m, num; 

//////////////////////////
//...\E8\ED\E8\F6\E8\E0\EB\E8\E7\E0\F6\E8\FF \EC\EE\E4\E5\EB\E8;
	CDraft<double> * sm = CreateDraft(HYDRO3D_DRAFT, 8);		
	sm->set_mpls(PackInts(3, 3)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(4, 4)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(1.*L*sqrt(3.)/(.5*rad));	//...\ED\EE\F0\EC\E8\F0\F3\FE\F9\E8\E9 \EC\ED\EE\E6\E8\F2\E5\EB\FC;
	sm->set_geometry(rad);			//...\F0\E0\E4\E8\F3\F1 \F1\F4\E5\F0\E8\F7\E5\F1\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF; 
	sm->set_lagrange(1e5);			//...\EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2 \CB\E0\E3\F0\E0\ED\E6\E0; 
	sm->set_fasa_hmg(k0);			//...\EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2 \C1\F0\E8\ED\EA\EC\E0\ED\E0; 
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*/);

//////////////////////////////////////////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5 \E8\EB\E8 \E7\E0\E4\E0\ED\E8\E5 \E3\E5\EE\EC\E5\F2\F0\E8\E8 \E0\ED\E0\EB\E8\F2\E8\F7\E5\F1\EA\E8;
	int id_analyt = 1;
	if (sm && ! id_analyt) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);
		sm->SetGeomBounding(par);

		Message("Finish!");
	}
	else 
	if (id_analyt) {//...\E7\E0\E4\E0\ED\E8\E5 \E3\E5\EE\EC\E5\F2\F0\E8\E8 \E0\ED\E0\EB\E8\F2\E8\F7\E5\F1\EA\E8;
		if (rad < 0.5)
		sm->GetSphBoxStruct(2.*L, 2.*L, 2.*L, rad, layer, OK_STATE); else
		sm->GetPenetrateSphere(rad, L); 
		sm->set_geometry(rad, layer);
		if (layer == 0.) sm->SetBUniStruct( CLAYER_BLOCK, ERR_GENUS);
		else				  sm->SetBUniStruct(1, POLY_BLOCK, ERR_GENUS);
		par[0] = -L; par[2] = -L; par[4] = -L;
		par[1] =  L; par[3] =  L; par[5] =  L;
	}

//////////////////////////////////////////////////
//...\F3\F1\F2\E0\ED\E0\E2\EB\E8\E2\E0\E5\EC \E3\F0\E0\ED\E8\F7\ED\FB\E5 \EF\EE\E2\E5\F0\F5\ED\EE\F1\F2\E8 \E2 \EC\EE\E4\E5\EB\E8;
	if (! id_analyt && 0) {
		double eps = 1e-6;
		sm->BlockActivate();
		sm->add_sph_surface(-rad, -L,  L, L);
		sm->add_sph_surface(-rad,  L,  L, L);
		sm->add_sph_surface(-rad,  L, -L, L);
		sm->add_sph_surface(-rad, -L, -L, L);
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, i, m) 
		if (sm->B[k].link[i+1] <= ERR_STATE && SRF_STATE < sm->B[k].link[i+1] && sm->bar && sm->bar->graph) {
			int N_arc, arc, prev = sm->B[k].bar->ce[i]->graph[(N_arc = sm->B[k].bar->ce[i]->graph[1])+1], m1, m2;
			for (j = 1, num = ERR_STATE; j <= N_arc; j++, prev = arc) if (num == ERR_STATE) {
				arc = sm->B[k].bar->ce[i]->graph[j+1];
				m1  = get_num(sm->B[k].bar->ce[i]->ce[arc]->graph, 0),
				m2  = get_num(sm->B[k].bar->ce[i]->ce[arc]->graph, 1);
				if (! sm->B[k].bar->ce[i]->ce[prev]->topo_id(m1)) swap(m1, m2);

				if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] < L-eps && sm->B[k].bar->ce[i]->ce[m1]->mp[1] > -L+eps &&
					 sm->B[k].bar->ce[i]->ce[m1]->mp[2] < L-eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] > -L+eps &&
					 sm->B[k].bar->ce[i]->ce[m1]->mp[3] < L-eps && sm->B[k].bar->ce[i]->ce[m1]->mp[3] > eps) {
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] < -eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] >  eps) num = 0; else
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] >  eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] >  eps) num = 1; else
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] >  eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] < -eps) num = 2; else
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] < -eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] < -eps) num = 3;
				}
			}
			if (num != ERR_STATE) sm->B[k].link[i+1] = SRF_STATE-num;
		}
	}

////////////////////////////////////////////////////////////////////////////////////
//...\E7\E0\E4\E0\ED\E8\E5 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \E7\ED\E0\F7\E5\ED\E8\E9 \E2 \EC\EE\E4\E5\EB\E8 (\EF\E5\F0\E8\EE\E4\E8\F7\ED\EE\F1\F2\FC \E7\E0\E1\E8\E2\E0\E5\F2 \E3\F0\E0\ED\E8\F7\ED\FB\E5 \E7\ED\E0\F7\E5\ED\E8\FF);
	int id_action = 0;
	if (id_action) {
		double po[6] = { 0., 0., 0., 0., 0., 0.};
		sm->BlockActivate();
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, num, m) {
			((CCeBasic *)sm->B[k].bar)->SetFacetXParam(num, par[0], po, ADHESION_BND);
			((CCeBasic *)sm->B[k].bar)->SetFacetXParam(num, par[1], po, ADHESION_BND);

			((CCeBasic *)sm->B[k].bar)->SetFacetYParam(num, par[2], po, ADHESION_BND);
			((CCeBasic *)sm->B[k].bar)->SetFacetYParam(num, par[3], po, ADHESION_BND);

			((CCeBasic *)sm->B[k].bar)->SetFacetZParam(num, par[4], po, SPECIAL_BND);
			((CCeBasic *)sm->B[k].bar)->SetFacetZParam(num, par[5], po, SPECIAL_BND);
		}
	}

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		if (sm) delete sm;
		goto err;
	}

////////////////////////////////////////////////////////////////
//..\E2\FB\F7\E8\F1\EB\FF\E5\EC \EE\F1\F0\E5\E4\ED\E5\ED\ED\FB\E5 \F5\E0\F0\E0\EA\F2\E5\F0\E8\F1\F2\E8\EA\E8 (\F2\E5\ED\E7\EE\F0 \EF\F0\EE\ED\E8\F6\E0\E5\EC\EE\F1\F2\E8);
		double K[4], nn, nn_cyl, nn_l, ff_vol, AX = 1., AY = 1., AZ = 1.; memset(K, 0, 4*sizeof(double));
		sm->GetRigidy(K, -1,  BASIC_COMPUT); 	

		ff_vol = K[3]/(AX*AY*AZ);
		if (AX*.5 > rad)
		ff_vol = 1.-4./3.*M_PI*rad/AX*rad/AY*rad/AZ; else
		ff_vol = 1.-2.*M_PI*(3.*rad/AY*rad/AZ*.5-.125-4./3.*rad/AX*rad/AY*rad/AZ);
		
		nn = K[2]/(AX*AY*AZ);
		nn_cyl = sm->TakeCylinder(ff_vol);
		nn_l	 = sm->TakeLayer	 (ff_vol);

		FILE  * TST = fopen("hydro_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  nn = %g  nn_cyl = %g  nn_l = %g  (AX = %g  AY = %g  k0 = %g)\n", ff_vol, nn, nn_cyl, nn_l, AX, AY, k0);
		fclose (TST);

//////////////////
//..visualization;
	{
		int id_visual = 1;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			int NX = 200, NY = 200, axis;

			sm->BlockActivate();

#ifdef ___LONGITUDINAL_SECTIOM___
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0], eps_in);
				nd->hit[i+j*nd->N] = hit;
			}
			axis = AXIS_Z;
#else
			if (1) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z((par[3]+par[2])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Y[j], nd->Z[0], nd->X[i], eps_in);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_Y;
			}
			else {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z((par[1]+par[0])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Z[0], nd->X[i], nd->Y[j], eps_in);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_X;
			}
#endif
//////////////////////////////////////
//...\EA\EE\F0\F0\E5\EA\F6\E8\FF \F1\F4\E5\F0\E8\F7\E5\F1\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1; else
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+layer)) nd->hit[i+j*nd->N] = 1/*1*/; 
				else nd->hit[i+j*nd->N] = 0/*0*/;
/*				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
	*/		}
			system("del *.grd");
			//sm->GetSurferFormat("bb", nd,	     ERR_VALUE, 0, axis); 
			sm->GetSurferFormat("pp", nd,	PRESSURE_VALUE, 0, axis);
			sm->GetSurferFormat("vv", nd, VELOCITY_VALUE, 0, axis);
			//sm->GetSurferFormat("nn", nd, NORMAL_R_VALUE, 0, axis);
			//sm->GetSurferFormat("nz", nd, NORMAL_Z_VALUE, 0, axis);

			nd->zero_grid();
			
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0], eps_in);
				nd->hit[i+j*nd->N] = hit;
			}
			axis = AXIS_Z;

////////////////////////////////////////////////
//...\EF\EE\E2\F2\EE\F0\ED\E0\FF \EA\EE\F0\F0\E5\EA\F6\E8\FF \F1\F4\E5\F0\E8\F7\E5\F1\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1; else
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+layer)) nd->hit[i+j*nd->N] = 1/*1*/; 
				else nd->hit[i+j*nd->N] = 0/*0*/;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
			}
			//sm->GetSurferFormat("bb_I", nd,	    ERR_VALUE, 0, axis);
			sm->GetSurferFormat("pp_I", nd, PRESSURE_VALUE, 0, axis);
			sm->GetSurferFormat("vv_I", nd, VELOCITY_VALUE, 0, axis);

			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_VIBRO
{
//	char * name = "Models_nas/Cylinder/cyl_cyl_40.nas";
//	char * name = "Models_nas/Acoustic/ono_box_56.nas";
//	char * name = "Models_nas/Acoustic/ono_box_140.nas";
//	char * name = "Models_nas/Acoustic/ono_box_172.nas";
//	char * name = "Models_nas/Acoustic/ono_box_320.nas";
//	char * name = "Models_nas/Acoustic/ono_box_412.nas";

//	char * name = "Models_nas/Acoustic/ono_half_14.nas";
//	char * name = "Models_nas/Acoustic/ono_half_35.nas";
//	char * name = "Models_nas/Acoustic/ono_half_43.nas";
//	char * name = "Models_nas/Acoustic/ono_half_80.nas";
	char * name = "Models_nas/Acoustic/ono_half_103.nas";
//	char * name = "Models_nas/Acoustic/ono_half_243.nas";
//	char * name = "Models_nas/Acoustic/ono_half_349.nas";

//	char * name = "Models_nas/Acoustic/ono0half_4.nas";
//	char * name = "Models_nas/Acoustic/ono0half_16.nas";
//	char * name = "Models_nas/Acoustic/ono0half_20.nas";
//	char * name = "Models_nas/Acoustic/ono0half_42.nas";
//	char * name = "Models_nas/Acoustic/ono0half_120.nas";

	int  i, j, k, l, N0, NN[] = {3, 1, 1, 1}, id_phase = OK_STATE;
	double  par[6], LL[] = {1.2, 1.3, 2.5};//...\F3\EA\E0\E7\FB\E2\E0\FE\F2\F1\FF \E2\EE\E7\F0\E0\F1\F2\E0\FE\F9\E8\E5 \E7\ED\E0\F7\E5\ED\E8\FF \F2\EE\F7\E5\EA;

//////////////////////////
//...\E8\ED\E8\F6\E8\E0\EB\E8\E7\E0\F6\E8\FF \EC\EE\E4\E5\EB\E8;
	CDraft<double> * sm = CreateDraft(ACOU3D_DRAFT, 8);		
	sm->set_mpls(PackInts(3, 1)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(4, 4)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(.92);	//...\ED\EE\F0\EC\E8\F0\F3\FE\F9\E8\E9 \EC\ED\EE\E6\E8\F2\E5\EB\FC;
	sm->set_lagrange(1e5);			//...\EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2 \CB\E0\E3\F0\E0\ED\E6\E0; 
	sm->change_solv(/*PERIODIC_SOLVING*/SQUARE_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*/NO_PHASE);

	sm->set_param(2, 100.);


////////////////////////////
//...\EF\F0\E5\EE\E1\F0\E0\E7\EE\E2\E0\ED\E8\E5 \EE\E1\F0\E0\E7\F6\E0;
	CGrid_el	* nd = new CGrid_el;

	//N0 = sm->GetOnoBoxStruct(1.2, 1.0, 0.5, 0.5, 0.08, NN, LL, name, OK_STATE, id_phase);
	//sm->B[0].bar->cells_out("bar");

	for (k = 0; k < sm->N; k++) {
		if (sm->B[k].link[1] < 0) sm->B[k].type = POLY_BLOCK; else //ELLI_BLOCK; else //SPECIAL_BND_BLOCK; else //
										  sm->B[k].type = POLY_BLOCK;//ELLI_BLOCK;//
		if (sm->B[k].link[2] < 0) sm->B[k].type = ELLI_BLOCK;//POLY_BLOCK;//SPECIAL_BND_BLOCK;//
	}
	par[0] = 0.0; par[2] = 0.0; par[4] = 0.;
	par[1] = 0.6; par[3] = 0.5; par[5] = LL[NN[0]-1];

//////////////////////////////////////////
//...\EA\EE\F0\F0\E5\EA\F6\E8\FF \E3\F0\E0\ED\E8\F7\ED\FB\F5 \E7\ED\E0\F7\E5\ED\E8\E9 \E2\F0\F3\F7\ED\F3\FE;
	if (1) {
		double pp[6] = { 0., 0., 0., 0., 0., 0.};
		for (k = 0; k < sm->N; k++)
		for (int num = 0; num < sm->B[k].bar->graph[0]; num++) 
		if  (sm->B[k].bar->ce[num]->cells_dim() == 2 && sm->B[k].bar->ce[num]->mp && sm->B[k].bar->ce[num]->graph && 
			  sm->B[k].bar->ce[num]->mp[l = size_of_map (sm->B[k].bar->ce[num]->mp)] == FACET_CELL && 
			  sm->B[k].bar->ce[num]->mp[l+1] > 0. && sm->B[k].bar->ce[num]->graph[1] > 2) {
			if (sm->B[k].link[sm->NUM_PHASE] == -2) {
				((CCeBasic *)sm->B[k].bar)->SetFacetXParam(num, par[0], pp, FSKEWS_BND);
				((CCeBasic *)sm->B[k].bar)->SetFacetXParam(num, par[1], pp, FSKEWS_BND);

				((CCeBasic *)sm->B[k].bar)->SetFacetYParam(num, par[2], pp, FSKEWS_BND);
				((CCeBasic *)sm->B[k].bar)->SetFacetYParam(num, par[3], pp, FSKEWS_BND);
			}
		}
	}

//////////////////////////
//...\F0\E0\F1\EF\E5\F7\E0\F2\EA\E0 \E3\E5\EE\EC\E5\F2\F0\E8\E8;
	for (k = 0; k < sm->N;  k++) {
	sm->B[k].bar->cells_out("bar");
	sm->B[k].bar->grid_skeleton(nd);
	}
	nd->grid_out("beam_bars25_blocks.bln", 0., 0., 0., AXIS_Z);
	nd->zero_grid();

///////////////////////////`
//...parameters of problem;
	double Hz  = 200.,   //...frequency;
			 Ro0 = 1.225,  //...air density (\EA\E3/\EC^3); 
			 C0  = 340.,   //...air velocity (\EC/\F1\E5\EA);
			 Ro1 = 9.8e3,  //...steel density (\EA\E3/\EC^3);
			 nj1 = 0.30,   //...steel Poisson; 
			 G1  = 2.04e10/(1.+nj1)*.5; //...steel modulus (\EA\C3/\EC^2);
	if (sm->type() == ACOU3D_DRAFT) sm->set_fasa_hmg(Hz, Ro0, C0);
	else 									  sm->set_fasa_hmg(Hz, Ro0, C0, Ro1, nj1, G1);

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(BASIC_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		if (sm) delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.ordtype = 1;
		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-4;
		params.theta = 0.10e0;
		params.niter = 200;
		params.eps = 1.0e-12;

		params.memory = 10.0e0;
		params.msglev = 3;

		params.ittype = 2;
		params.sttype = 1;

		std::ofstream fout ("BsSolver.dat");

		sm->shapes_init(NO_STATE); 
		BMM_solvrC pBMM = {& sm->solver, sm, BASIC_COUNTING};
//		AbstractSolver		(& pBMM, 
		AbstractParSolver (& pBMM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks, Blocks_Partitioning,	Blocks_Sparsity,  
								Blocks_RowC, Right_HandsideC, Initial_GuessC, Store_SolutionC);
		sm->shapes_init(OK_STATE); 
	}
#endif
//	sm->block_descrap("Descrapency.sta");

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		int id_visual = 1, id_symm = 1;
		if (id_visual) {
			int NX = 100, NY = 100, axis;
			nd->zero_grid();

#ifdef ___LONGITUDINAL_SECTIOM___ 
			if (id_symm) {
				((par[1] -= par[0]) *= 2.) += par[0]; 
				((par[3] -= par[2]) *= 2.) += par[2]; 
			}
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			if (id_symm) {
				for (((par[1] -= par[0]) /= 2.) += par[0], i = NX; i <= 2*NX; i++) nd->X[i] = 2.*(par[1]+par[0])-nd->X[i];
				for (((par[3] -= par[2]) /= 2.) += par[2], j = NY; j <= 2*NY; j++) nd->Y[j] = 2.*(par[3]+par[2])-nd->Y[j];
			}
			sm->hit_beam_struct(nd, N0, NN, LL, axis = AXIS_Z);
#else
			if (1) {
				if (id_symm) 
					((par[1] -= par[0]) *= 2.) += par[0]; 
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z(par[3]);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				if (id_symm) 
					for (((par[1] -= par[0]) /= 2.) += par[0], j = NY+1; j <= 2*NY; j++) nd->Y[j] = 2.*(par[1]+par[0])-nd->Y[j];
				sm->hit_beam_struct(nd, N0, NN, LL, axis = AXIS_Y);
			}
			else {
				if (id_symm) 
					((par[3] -= par[2]) *= 2.) += par[2]; 
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z((par[1]+par[0])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				if (id_symm)
					for (((par[3] -= par[2]) /= 2.) += par[2], i = NX+1; i <= 2*NX; i++) nd->X[i] = 2.*(par[3]+par[2])-nd->X[i];
				sm->hit_beam_struct(nd, N0, NN, LL, axis = AXIS_X);
			}
#endif
			system("del *.grd");
			sm->GetSurferFormat("bb",  nd,	 ERR_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
			sm->GetSurferFormat("pp",  nd,	 SPL_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("pz",  nd,  PRESS_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("vz",  nd, FLUX_Z_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("ppp", nd,    SPL_ANALYT_ABSORB_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("ppz", nd,  PRESS_ANALYT_ABSORB_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("vvz", nd, FLUX_Z_ANALYT_ABSORB_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
		}
		int id_action = 1;
		if (id_action) {
			int NX = 40, NY = 40;

			nd->zero_grid();
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(LL[0]);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			nd->Z[0] -= 0.001;
			sm->hit_beam_struct(nd, N0, NN, LL, AXIS_Z);
			nd->Z[0] += 0.001;

			FILE * TST = fopen("resi_L1.dat", "w");
			double out_F[3], sum[3], eps = 1e-12;
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 PRESSURE_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, PRESSURE_VALUE, 0);
				fprintf(TST, " %i  %g  %g  (norm = %g)", i, 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));

				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 FLUX_Z_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, FLUX_Z_VALUE, 0);
				fprintf(TST, "    %g  %g  (norm = %g)\n", 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));
			}
			fclose(TST);

			nd->zero_grid();
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(LL[1]);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			nd->Z[0] -= 0.001;
			sm->hit_beam_struct(nd, N0, NN, LL, AXIS_Z);
			nd->Z[0] += 0.001;

			TST = fopen("resi_L2.dat", "w");
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 PRESSURE_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, PRESSURE_VALUE, 0);
				fprintf(TST, " %i  %g  %g  (norm = %g)", i, 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));

				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 FLUX_Z_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, FLUX_Z_VALUE, 0);
				fprintf(TST, "    %g  %g  (norm = %g)\n", 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));
			}
			fclose(TST);
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef LAME3D_LAYERED_ESHELBY_HOMOGENIZATION
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(COHES3D_DRAFT, 8),
						* lm = CreateDraft(LAME2D_DRAFT, 8);
	double nju1 = 0.30, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.30, //...\F1\EB\EE\E9;
			 nju3 = 0.22, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 E1   = 0.012,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 0.045,//...\F1\EB\EE\E9;
			 E3   = 30.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 kk1	= E1*(.5+nju1)/(1.+nju1), //...\EC\EE\E4\F3\EB\FC \F0\E0\F1\F2\FF\E6\E5\ED\E8\FF/\F1\E6\E0\F2\E8\FF \EC\E0\F2\F0\E8\F6\FB;
			 kk2	= E2*(.5+nju2)/(1.+nju2), //...\F1\EB\EE\E9;
			 kk3	= E3*(.5+nju3)/(1.+nju3), //...\EC\EE\E4\F3\EB\FC \F0\E0\F1\F2\FF\E6\E5\ED\E8\FF/\F1\E6\E0\F2\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 l0	= 0.10, //...interphase layer;
			 c0   = 0.20, //...volume fraction; 
			 G1, G2, GH = 0., G0, EH, E_min, E_max, KH, KK = 0., KD;

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	const int N = 3;
	double ff[N] = {(1.-c0)*2./3., (1.-c0)*1./3., c0}, kk[N] = {kk1, kk2, kk3}, ll[N] = {l0, l0, l0}, 
			 mu[N] = {2.*E1*(1.+nju1), 2.*E2*(1.+nju2), 2.*E3*(1.+nju3)}; 
	//double ff[N] = {(1.-c0), c0}, kk[N] = {kk1, kk2}, ll[N] = {l0, l0}, 
	//		 mu[N] = {2.*E1*(1.+nju1), 2.*E2*(1.+nju2)}; 
	FILE * TST = fopen("Layered_homog.dat", "w");
	for (int j = 0; j <= 1000; j += 1) {
		c0 = j*.001; ff[0] = (1.-c0)*2./3.; ff[1] = (1.-c0)*1./3.; ff[2] = c0;
		
		E_min = sm->TakeLayer_kk(N, ff, kk); E_max = 0.;
		EH = sm->TakeLayer_kk(N, ff, kk, ll);
		for (int i = 0; i < N; i++) E_max += ff[i]*kk[i];

		KH = lm->TakeLayer_kk(N, ff, kk, mu); GH = 0.;
		KD = ((kk[0]-kk[2])-ff[1]/(ff[0]+ff[1])*(1.+(kk[2]-kk[1])/(kk[1]+mu[1]))*(kk[0]-kk[1]))/(1.+ff[1]/(ff[0]+ff[1])*(kk[0]-kk[1])/(kk[1]+mu[1]));
		KK = kk[2]+(ff[0]+ff[1])*KD/(1.+ff[2]*KD/(kk[2]+mu[2]));
		//GH = lm->TakeLayer_GG(N, ff, kk, mu);

		lm->set_fasa_hmg(nju1, nju2, E1/(1.+nju1)*.5, E2/(1.+nju2)*.5, nju3, E3/(1.+nju3)*.5);
		KD = lm->TakeEshelby_volm(ff[0], ff[1]);

  		fprintf(TST, " l0 = %g, c0 = %g, EH = %g, E_min = %g, E_max = %g, KH = %g, GH = %g, KK = %g, KD = %g\n", l0, c0, EH, E_min, E_max, KH, GH, KK, KD);
	}
	fclose (TST);
	delete sm;
}
#endif
#ifdef CHYDRO3D_ANALYT_HOMOGENIZATION
{
	double par[6], rad = 0.5, h_rad = 0., L = 0.5, alpha = 0., section = 0., section_I = 0., section_II = 0.;
	int id_visual = 0, axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X, NX = 100, NY = 100, N_elem = 4, N_max = 2, 
		 structure = 0, N_rad = 1, N0 = 7, i, j, k, l, m, num;
	char name[2000]; name[0] = 0;

//////////////////////////////////
//...reading model from data-file;`
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("hydro3D_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found...");
		Message(" ");
		Message(buf); 
		sprintf(buf, "Creating data file \"hydro3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("hydro3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "structure = %i\nname = %s\n\n", structure, name);
		fprintf(TST, "rad = %g  h_rad = %g  N_rad = %i\nalpha = %g\n\n", rad, h_rad, N_rad, alpha);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("structure = %i\nname = %s\n\n", structure, name);
		printf("rad = %g  h_rad = %g  N_rad = %i\nalpha = %g\n\n", rad, h_rad, N_rad, alpha);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) structure = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && structure &&  
		user_Read (buf, id_DATA, count, upper_limit)) ::strcpy(name, buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) h_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_rad = atoi(buf);
	
	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) alpha = user_strtod(buf);

//////////////////////////////////////
//...creating model from initial data;
test:
	CDraft<double> * sm = CreateDraft(HYDRO3D_DRAFT, 8);		
	sm->set_mpls(PackInts(N0, N0)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(N_elem, N_max));
	sm->set_normaliz(L*sqrt(3.)/(.5*rad));			  //...\ED\EE\F0\EC\E8\F0\F3\FE\F9\E8\E9 \EC\ED\EE\E6\E8\F2\E5\EB\FC; 
	sm->set_lagrange(1e5);			  //...\EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2 \CB\E0\E3\F0\E0\ED\E6\E0; 
	sm->set_fasa_hmg(alpha);		  //...\EA\EE\FD\F4\F4\E8\F6\E8\E5\ED\F2 \C1\F0\E8\ED\EA\EC\E0\ED\E0; 
	sm->change_solv(structure ? SQUARE_SOLVING : SPECIAL_SOLVING);
	sm->solver.set_mode(/*PRINT_MODE*/);

///////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	if (sm && structure && structure != 3) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct();
		sm->SetGeomBounding(par); 
		if (structure == 1) sm->solver.change_state(EXTERN_STATE); 
		N_rad = 1;
		Message("Finish!");

///////////////////////////////////////////////////////////////////////////////////////////
//...\E7\E0\E4\E0\ED\E8\E5 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \E7\ED\E0\F7\E5\ED\E8\E9 \E2 \EC\EE\E4\E5\EB\E8 (\F1\EA\EE\F0\EE\F1\F2\FC \EF\EE\EF\E5\F0\E5\EA \EF\EE\F2\EE\EA\E0 \E8 \E4\E0\E2\EB\E5\ED\E8\E5 \E2\E4\EE\EB\FC \EF\EE\F2\EE\EA\E0);
		double po[6] = { 0., 0., 0., 0., 0., 0.};
		sm->BlockActivate();
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, num, m) {
			((CCeBasic *)sm->B[k].bar)->SetFacetXParam(num, par[0], po, FSKEWS_BND);
			((CCeBasic *)sm->B[k].bar)->SetFacetXParam(num, par[1], po, FSKEWS_BND);

			((CCeBasic *)sm->B[k].bar)->SetFacetYParam(num, par[2], po, FSKEWS_BND);
			((CCeBasic *)sm->B[k].bar)->SetFacetYParam(num, par[3], po, FSKEWS_BND);
			
			((CCeBasic *)sm->B[k].bar)->SetFacetZParam(num, par[4], po, SPECIAL_BND);
			((CCeBasic *)sm->B[k].bar)->SetFacetZParam(num, par[5], po, SPECIAL_BND);
		}
	}

////////////////////////////////////////////////////////
//...\EF\E5\F0\E5\E1\E8\F0\E0\E5\EC \E2\F1\E5 \F0\E0\E4\E8\F3\F1\FB, \EE\F2\EA\EB\FE\F7\E0\FF \EF\F0\E5\E4\E5\EB\FC\ED\FB\E5 \F1\EB\F3\F7\E0\E8;
	res = system("mkdir var2_results"); char buff1[200], buff2[200], str[40];
//	res = system("del *.grd");
	for (l = 0; l < N_rad; l++, rad += h_rad) { 
		sprintf(buf, "rad = %g", rad);
		Message(" ");
		Message(buf);
		if (rad > 0. && rad < M_SQRT_2 || structure) {
			if (! structure || structure == 3) { //...\E7\E0\E4\E0\ED\E8\E5 \E3\E5\EE\EC\E5\F2\F0\E8\E8 \E0\ED\E0\EB\E8\F2\E8\F7\E5\F1\EA\E8;
				if (rad < 0.5)
				sm->GetSphBoxStruct(2.*L, 2.*L, 2.*L, rad, 0., OK_STATE); else
				sm->GetPenetrateSphere(rad, L);
				sm->SetBUniStruct(CLAYER_BLOCK, ERR_GENUS);
				sm->set_geometry(rad);
				par[0] = -L; par[2] = -L; par[4] = -L;
				par[1] =  L; par[3] =  L; par[5] =  L;
				if (1) { //...\E7\E0\E4\E0\ED\E8\E5 \EA\F0\E0\E5\E2\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \ED\E0 \E1\EE\EA\EE\E2\FB\F5 \E3\F0\E0\ED\FF\F5;
					double po[6] = { 0., 0., 0., 0., 0., 0.};
					LOOP_FACET(sm->B[0].bar, num, m) {
						((CCeBasic *)sm->B[0].bar)->SetFacetXParam(num, par[0], po, FSKEWS_BND);
						((CCeBasic *)sm->B[0].bar)->SetFacetXParam(num, par[1], po, FSKEWS_BND);

						((CCeBasic *)sm->B[0].bar)->SetFacetYParam(num, par[2], po, FSKEWS_BND);
						((CCeBasic *)sm->B[0].bar)->SetFacetYParam(num, par[3], po, FSKEWS_BND);
						
						((CCeBasic *)sm->B[0].bar)->SetFacetZParam(num, par[4], po, SPECIAL_BND);
						((CCeBasic *)sm->B[0].bar)->SetFacetZParam(num, par[5], po, SPECIAL_BND);
					}
				}
			}

///////////////////////////
//...solving of the probem;
			if (sm->computing_kernel(structure ? BASIC_COMPUT : PERIOD_COMPUT) != OK_STATE)
				Message("Error in sample counting...");

////////////////////////////////////////////////////////////////
//..\E2\FB\F7\E8\F1\EB\FF\E5\EC \F3\F1\F0\E5\E4\ED\E5\ED\ED\FB\E5 \F5\E0\F0\E0\EA\F2\E5\F0\E8\F1\F2\E8\EA\E8 (\F2\E5\ED\E7\EE\F0 \EF\F0\EE\ED\E8\F6\E0\E5\EC\EE\F1\F2\E8);
			double K[4], nn, nn_cyl, nn_cyl_alpha, nn_l, nn_l_alpha, ff_vol; memset(K, 0, 4*sizeof(double));
			sm->GetRigidy(K, -1,  BASIC_COMPUT); 	

			if (rad < 0.5)
			ff_vol = 1.-4./3.*M_PI*rad*rad*rad; else
			ff_vol = 1.-2.*M_PI*(1.5*rad*rad-4./3.*rad*rad*rad-0.125);
			nn = K[2]/K[3]*ff_vol;

			nn_cyl = sqr(ff_vol)/(8.*M_PI);
			nn_l	= sqr(ff_vol)*ff_vol/12.; 

			nn_cyl_alpha = sm->TakeCylinder(ff_vol);
			nn_l_alpha	 = sm->TakeLayer	 (ff_vol);

			FILE  * TST = fopen("var2_results/hydro3d_homog.dat", "a");
			fprintf(TST, "ff_vol = %g  vol = %g  nn = %g  nn_cyl = %g/%g  nn_l = %g/%g  (rad = %g  alpha = %g  N_mpls = %i)\n", 
							  ff_vol, K[3], nn, nn_cyl_alpha, nn_cyl, nn_l_alpha, nn_l, rad, alpha, N0);
			fclose (TST);

//////////////////
//..visualization;
			sprintf(str, "%g", rad); sprintf(buff1, "var2_results/pp_%s", str); sprintf(buff2, "var2_results/vv_%s", str);
			if (id_visual) { //..visualization;
				CGrid_el * nd = new CGrid_el;
				if (axis == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
				}
				if (axis == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
				}
				if (axis == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
				}
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				if (structure && structure != 3)
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					if (axis == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0]); else
					if (axis == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i]); else
					if (axis == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j]);
					//if (structure > 1) { //...\EA\EE\F0\F0\E5\EA\F6\E8\FF \EA\E0\ED\E0\EB\E0 \EC\E5\E6\E4\F3 \F1\F4\E5\F0\E8\F7\E5\F1\EA\E8\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//}
					nd->hit[i+j*nd->N] = hit;
				}
				else
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++)
					if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1;

				//system("del *.grd");
				//sm->GetSurferFormat("bb", nd,	     ERR_VALUE, 0, axis);
				//sm->GetSurferFormat("pp", nd,	PRESSURE_VALUE, 0, axis);
				//sm->GetSurferFormat("vv", nd, VELOCITY_VALUE, 0, axis);

				sm->GetSurferFormat(buff1, nd,	PRESSURE_VALUE, 0, axis);
				sm->GetSurferFormat(buff2, nd, VELOCITY_VALUE, 0, axis);

				//sm->GetDataFormat("pp", nd, PRESSURE_VALUE, 0, axis);
				//sm->GetDataFormat("vv", nd, VELOCITY_VALUE, 0, axis);
				//if (axis == AXIS_Z && ! structure) {
				//	for (i = 0; i < nd->N;  i++)
				//	for (j = 0; j < nd->N1; j++) 
				//		if (sqr(nd->X[i])+sqr(nd->Y[j]) > sqr(rad)) nd->hit[i+j*nd->N] = -1; else nd->hit[i+j*nd->N] = 0;
				//	sm->GetSurferFormat("vv_analyt", nd, ANALYT_VALUE, 0, axis);
				//}

/////////////////////////////////////////
//...\E4\EE\EF\EE\EB\ED\E8\F2\E5\EB\FC\ED\FB\E5 \F1\E5\F7\E5\ED\E8\FF (\E5\F1\EB\E8 \ED\F3\E6\ED\EE);
				if (id_visual > 1) { 
					nd->zero_grid();
					if (axis_I == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
					}
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					if (structure && structure != 3)
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						if (axis_I == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0]); else
						if (axis_I == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i]); else
						if (axis_I == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j]);
						//if (structure > 1) { //...\EA\EE\F0\F0\E5\EA\F6\E8\FF \EA\E0\ED\E0\EB\E0 \EC\E5\E6\E4\F3 \F1\F4\E5\F0\E8\F7\E5\F1\EA\E8\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//}
						nd->hit[i+j*nd->N] = hit;
					}
					else
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++)
						if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1;

					//sm->GetSurferFormat("bb_I", nd,	    ERR_VALUE, 0, axis_I);
					sm->GetSurferFormat("pp_I", nd, PRESSURE_VALUE, 0, axis_I);
					sm->GetSurferFormat("vv_I", nd, VELOCITY_VALUE, 0, axis_I);

					//sm->GetDataFormat("pp_I", nd, PRESSURE_VALUE, 0, axis_I);
					//sm->GetDataFormat("vv_I", nd, VELOCITY_VALUE, 0, axis_I);
					//if (axis_I == AXIS_Z && ! structure) {
					//	for (i = 0; i < nd->N;  i++)
					//	for (j = 0; j < nd->N1; j++) 
					//		if (sqr(nd->X[i])+sqr(nd->Y[j]) > sqr(rad)) nd->hit[i+j*nd->N] = -1; else nd->hit[i+j*nd->N] = 0;
					//	sm->GetSurferFormat("vv_analyt", nd, ANALYT_VALUE, 0, axis_I);
					//}

					if (id_visual > 2) { 
						nd->zero_grid();
						if (axis_II == AXIS_Z) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
							nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_Y) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
							nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_X) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
							nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
						}
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						if (structure && structure != 3)
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++) {
							int hit = -1;
							if (axis_II == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0]); else
							if (axis_II == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i]); else
							if (axis_II == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j]);
							//if (id_structure > 1) { //...\EA\EE\F0\F0\E5\EA\F6\E8\FF \EA\E0\ED\E0\EB\E0 \EC\E5\E6\E4\F3 \F1\F4\E5\F0\E8\F7\E5\F1\EA\E8\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//}
							nd->hit[i+j*nd->N] = hit;
						}
						else
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++)
							if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1;

						//sm->GetSurferFormat("bb_II", nd,	     ERR_VALUE, 0, axis_II);
						sm->GetSurferFormat("pp_II", nd, PRESSURE_VALUE, 0, axis_II);
						sm->GetSurferFormat("vv_II", nd, VELOCITY_VALUE, 0, axis_II);

						//sm->GetDataFormat("pp_II", nd, PRESSURE_VALUE, 0, axis_II);
						//sm->GetDataFormat("vv_II", nd, VELOCITY_VALUE, 0, axis_II);
						//if (axis_II == AXIS_Z && ! structure) {
						//	for (i = 0; i < nd->N;  i++)
						//	for (j = 0; j < nd->N1; j++) 
						//		if (sqr(nd->X[i])+sqr(nd->Y[j]) > sqr(rad)) nd->hit[i+j*nd->N] = -1; else nd->hit[i+j*nd->N] = 0;
						//	sm->GetSurferFormat("vv_analyt", nd, ANALYT_VALUE, 0, axis_II);
						//}
					}
				}
				delete nd;
			}
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_LAME3D_INTERMEDIATE_PHASE
{
	double AX = 1., AY = 1., AZ = 1., rad = 0.0895, ll = 0.08;
	int i, j;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(LAME3D_DRAFT/*COHES3D_DRAFT*/, 8);
	sm->set_mpls(PackInts(13, 9)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(8, 4)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);			//...\ED\EE\F0\EC\E8\F0\F3\FE\F9\E8\E9 \EC\ED\EE\E6\E8\F2\E5\EB\FC;
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*//*FULLY_MODE*/);

//////////////////////
//...\EF\E0\F0\E0\EC\E5\F2\F0\FB \E7\E0\E4\E0\F7\E8;
	double nj1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0; 
			 nj2 = 0.20, //...\E3\F0\E0\F4\E8\F2\EE\E2\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5; 
			 nj3 = 0.30, //...\EC\E5\E6\F4\E0\E7\ED\FB\E9 \F1\EB\EE\E9; 
			 E1  = 18.,  //...GPa;
			 E2  = 380., //...GPa; 
			 E3  = 57.5, c0, c1, par[6]; 
	sm->set_fasa_hmg(rad, rad+ll, nj2, nj3, nj1, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5, E1/(1.+nj1)*.5);

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	int n_var;
	res = system("mkdir var1_results");
	for (rad = 0., c0 = 0., c1 = 0.4, n_var = 1; n_var <= 100; n_var++) {
		E2 = E1 +10.*n_var;
		sm->set_fasa_hmg(rad, rad+ll, nj2, nj3, nj1, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5, E1/(1.+nj1)*.5);

		//rad = pow(.75/M_PI*(c0 = j*.1), 1./3.); ll = rad-pow(.75/M_PI*c0*c1, 1./3.); 
		//AX = AY = AZ = (rad = 0.037)/pow(.75/M_PI*(c0 = 0.00272), 1./3.); ll = 3.*rad;
		rad = pow(.75/M_PI*(c0 = 0.003), 1./3.); ll = 4.*rad;
		sm->set_geometry(rad, ll);

///////////////////////
//...\E3\E5\EE\EC\E5\F2\F0\E8\FF \EE\E1\EB\E0\F1\F2\E8;
		sm->GetSphBoxStruct(AX, AY, AZ, rad, ll);
		par[0] = -AX*.5; par[2] = -AY*.5; par[4] = -AZ*.5;
		par[1] =  AX*.5; par[3] =  AY*.5; par[5] =  AZ*.5;

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample counting...");
			delete sm;
			goto err;
		}

///////////////////////////////////////////////////////////////////////
//..\E2\FB\F7\E8\F1\EB\FF\E5\EC \EE\F1\F0\E5\E4\ED\E5\ED\ED\FB\E5 \F5\E0\F0\E0\EA\F2\E5\F0\E8\F1\F2\E8\EA\E8 (\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E8 \EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0);
		double K[28], E0, K0, nu, mu, C0, lm, ff_vol, ll_vol; memset(K, 0, 28*sizeof(double)); K[27] = AX*.5;
		sm->GetRigidy(K, -1, BASIC_COMPUT);
		sm->GetRigidy(K, -1, COVERING_COMPUT);

		ff_vol = K[25]/(K[24]+K[25]+K[26]);
		ll_vol = K[26]/(K[24]+K[25]+K[26]);

		C0 = (K[5]-2.*K[0]*K[6]/(K[6]+K[11]))/(K[11]-2.*K[6]*K[6]/(K[6]+K[11]));
		lm = (K[0]-C0*K[6])/(K[6]+K[11]);
		nu = lm/(C0+lm);
		E0 = (C0-lm)*(C0+2.*lm)/(C0+lm);
		K0 = E0/(3.*(1.-2.*nu));
		mu = K[15]/K[21]*.5;

		FILE  * TST = fopen("var1_results/lame3d_homog.dat", "a");
		fprintf(TST, "ff_vol+ll_vol = %g  K0 = %g  E0 = %g  mu = %g  nu = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol+ll_vol, K0, E0, mu, nu, rad, E2, E3, E1, nj2, nj3, nj1);
		fclose (TST);

//////////////////////////////////////////////////////////////
//..\F2\E5\F1\F2\E8\F0\F3\E5\EC \EF\EE\E2\E5\F0\F5\ED\EE\F1\F2\ED\FB\E5 \E7\ED\E0\F7\E5\ED\E8\FF \ED\E0 \E3\F0\E0\ED\E8\F6\E5 \F4\E0\E7 \EC\E0\F2\E5\F0\E8\E0\EB\E0;
	int id_testin = 0;
	if (id_testin) {
		extern int forced_phase;
		CGrid * nd = CreateNodes();
		int NX = 40, NY = 40;
		for (i = 0; i <= 2*NX; i++) 
		for (j = 0; j <= 2*NY; j++) {
			double Co = cos((M_PI*i)/NX*.5+M_PI*.25),
					 Si = sin((M_PI*i)/NX*.5+M_PI*.25),
					 C2 = cos((M_PI*j)/NY+M_PI*.25),
					 S2 = sin((M_PI*j)/NY+M_PI*.25), fff = rad;
			nd->add_new_point(fff*Si*C2, fff*Si*S2, fff*Co, Si*C2, Si*S2, Co);
		}
		double out_F[3], sum[3], eps = 1e-12, 
				 uu_resi_R1 = 0., uu_resi_R2 = 0., pn_resi_R1 = 0., pn_resi_R2 = 0., dd; forced_phase = -1;
		FILE * TST = fopen("uu_resi_R1.dat", "w");
		for (i = 1; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, DISPL_VALUE); forced_phase =  0;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, DISPL_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (uu_resi_R1 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) uu_resi_R1 = dd;
		}
		fclose(TST);

		TST = fopen("pn_resi_R1.dat", "w");
		for (i = 0; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, STRESS_R_VALUE); forced_phase =  0;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, STRESS_R_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (pn_resi_R1 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) pn_resi_R1 = dd;
		}
		fclose(TST);
		nd->zero_grid();
		for (i = 0; i <= 2*NX; i++) 
		for (j = 0; j <= 2*NY; j++) {
			double Co = cos((M_PI*i)/NX*.5),
					 Si = sin((M_PI*i)/NX*.5),
					 C2 = cos((M_PI*j)/NY),
					 S2 = sin((M_PI*j)/NY), fff = rad+ll;
			nd->add_new_point(fff*Si*C2, fff*Si*S2, fff*Co, Si*C2, Si*S2, Co);
		}
		TST = fopen("uu_resi_R2.dat", "w");
		forced_phase = -1;
		for (i = 0; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, DISPL_VALUE); forced_phase =  1;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, DISPL_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (uu_resi_R2 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) uu_resi_R2 = dd;
		}
		fclose(TST);

		TST = fopen("pn_resi_R2.dat", "w");
		for (i = 0; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, STRESS_R_VALUE); forced_phase =  1;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, STRESS_R_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (pn_resi_R2 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) pn_resi_R2 = dd;
		}
		fclose(TST);
		delete nd;
		forced_phase = -777;
		TST = fopen("all_resi.dat", "w");
		fprintf(TST, " uu_resi_R1 =  %g  pn_resi_R1 =  %g\n uu_resi_R2 =  %g  pn_resi_R2 =  %g\n", \
							uu_resi_R1, pn_resi_R1, uu_resi_R2, pn_resi_R2); 
		fclose(TST);
	}

//////////////////
//..visualization;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		int NX = 200, NY = 200, axis = AXIS_Y, alpha = 0;

		if (axis == AXIS_Z) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_Y) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

			nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_X) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

			nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		for (i = 0; i < nd->N;  i++)
		for (j = 0; j < nd->N1; j++) {
			if (rad == 0.) nd->hit[i+j*nd->N] = 0; else
			if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
			if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	
		}
		//system("del *.grd");
		sm->GetSurferFormat("var1_results/rz", nd,		DISPL_VALUE, 0, axis);
		sm->GetSurferFormat("var1_results/tz", nd, STRESS_Z_VALUE, 0, axis);

		delete nd;
	   }
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_LAME2D_FROM_FEMAP
{
	//char * name = "./Box2d_homog/heat_clayer488.nas";
	char * name = "./Box2d_homog/ell_80_20_i_1980.nas";
	//char * name = "./Box2d_homog/sph_025_16.nas";
	//char * name = "./Parametric/Unit2d_16.nas";

//////////////////////////
//...;
	CDraft<double> * sm = CreateDraft(LAME2D_DRAFT);
	sm->set_mpls(PackInts(7, 5)); //...;
	sm->set_quad(PackInts(16, 8)); //...;
	sm->set_normaliz(0.92);			  //...;
	sm->set_lagrange(1e5);			  //...; 
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);

//////////////////////
//...;
	double nju1 = 0.300,  //...; 
			 nju2 = 0.100,  //...); 
			 nju3 = 0.499,  //...; 
			 G1   = 6.0/(1.+nju1)*.5,	//...(GPa);
			 G2   = 50./(1.+nju2)*.5,	//...GPa); 
			 G3   = 1e-05/(1.+nju3)*.5; //...GPa); 
	sm->set_fasa_hmg(nju1, nju2, nju3, G1, G2, G3);

//////////////////////////////////////////////////////////////////////////////////////
//...;
//{	double c0 = 0.5, nj1 = 0.3, nj2 = 0.49, E1 = 1., E2 = 10, 
//			 k1 = E1*(1.-nj1)/((1.-2.*nj1)*(1.+nj1)), lm1 = nj1*k1/(1.-nj1),
//			 k2 = E2*(1.-nj2)/((1.-2.*nj2)*(1.+nj2)), lm2 = nj2*k2/(1.-nj2), eps, k_eff, k_low;
//	k_low = 1./((1.-c0)/k1+c0/k2);
//	eps	= c0*(1.-c0)/(k1*k2)*sqr(lm1-lm2)*k_low;
//	k_eff = k1*(1.-c0)+k2*c0;
//	return(0);
//}
//...;
///////////////////////
///////////////////////////////////////////////////////
//...;
	if (sm) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);
		Message("Finish!");
	}

////////////////////
//...;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		delete sm;
		goto err;
	}

//////////////////
//..visualization;
	double lambda = 0., RoC = 0., low_lambda = 0., ff_vol, E1, E2, E_low, E_big;
	CGrid * nd = CreateNodes();
	{
		double par[6];	sm->SetGeomBounding(par);
		double K[8] = {0., 0., 0., 0., 0., 0., 0., 0.};
		sm->GetRigidy(K);

		ff_vol = K[7]/((par[1]-par[0])*(par[3]-par[2])*(par[5]-par[4]));
		RoC	 = K[5]+(K[6]-K[5])*ff_vol;
		lambda = K[2]/((par[1]-par[0])*(par[3]-par[2])*(par[5]-par[4]));
		low_lambda = 1./(1./K[3]+(1./K[4]-1./K[3])*ff_vol);

		ff_vol = 0.3;
		E1 = sm->TakeLayer_E1(ff_vol);
		E2 = sm->TakeLayer_E2(ff_vol);
		E_big = ff_vol*2.*(1.+nju2)*G2+(1.-ff_vol)*2.*(1.+nju1)*G1;
		E_low = 1./(ff_vol/(2.*(1.+nju2)*G2)+(1.-ff_vol)/(2.*(1.+nju1)*G1));

		FILE *  TST = fopen("homog_15_3D.dat", "a");
		fprintf(TST, "%g    %g    %g     %g\n", ff_vol, lambda, low_lambda, RoC);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			nd->zero_grid();

			sm->BlockActivate(NULL_STATE);

			int NX = 200, NY = 200;
			for (int i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (int j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			int hit = ERR_STATE;
			for (int i = 0; i < nd->N;  i++)
			for (int j = 0; j < nd->N1; j++) {
				sm->Poly_struc_in2D(hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			system("del *.grd");

			sm->GetSurferFormat("bb", nd,       ERR_VALUE, 0);
			sm->GetSurferFormat("rx", nd,     DISPL_VALUE, 0);
			sm->GetSurferFormat("ry", nd,     DISPL_VALUE, 1);
			sm->GetSurferFormat("tx", nd,  STRESS_X_VALUE, 0);
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef TEST_DRAFT_COHES2D_FROM_FEMAP
{
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_84.inp";
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_172.inp";
	char * name_ini = "./Models_inp/Box2D_sph/sph_009_184.inp";
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_496.inp";

	//char * name_ini = "./Models_inp/Box2D_ellipt/Box2D_ellipt_1_4_480.inp";
	//char * name_ini = "./Models_inp/Box2D_ellipt/Box2D_ellipt_2_4_148.inp";
	//char * name_ini = "./Models_inp/Box2D_ellipt/Box2D_ellipt_05_4_160.inp";
	//char * name_ini = "./Models_inp/Box2D_short cylinder/Box2D_short_cyl_1_4.inp";
	//char * name_ini = "./Box2d_homog/ell_80_20_i.nas";
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	int  i, j, l, id_reading = 0;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(COHES2D_DRAFT, 8);
	sm->set_mpls(PackInts(2, 2)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(8, 8)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);
	sm->set_param(sm->size_of_param()-1, 1e4);
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(OK_STATE/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);

///////////////////////////
//...parameters of problem;
	//double nju1		= 0.39, //...matrix parameters; 
	//		 nju2		= 0.20, //...inclusion parameters; 
	//		 E1		= 3.41/(1.+nju1)*.5,  //...matrix parameters;
	//		 E2		= 87.5/(1.+nju2)*.5,  //...inclusion parameters;
	//		 l1		= 0.06, //...interphase layer as ration sqrt(G1/C1);
	//		 l2		= 0.1;  //...interphase layer as ration sqrt(G2/C2);
	double nju2		= 0.20, //...matrix parameters; 
			 nju1		= 0.30, //...inclusion parameters; 
			 E2		= 385./(1.+nju1)*.5,  //...matrix parameters;
			 E1		= 70./(1.+nju2)*.5,  //...inclusion parameters;
			 l1		= 0.1,  //...interphase layer as ration sqrt(G1/C1);
			 l2		= 0.06; //...interphase layer as ration sqrt(G2/C2);
	sm->set_param(3, 1.);  //...using gradient displacements;
	sm->set_fasa_hmg(nju1, nju2, E1/(1.+nju1)*.5, E2/(1.+nju2)*.5, E1/(1.+nju1)*.5/sqr(l1), E2/(1.+nju2)*.5/sqr(l2));

///////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name_ini);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name_ini);
      sm->bar_condit_in(name_ini);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	double par[6];	sm->SetGeomBounding(par);
	if (! id_reading) {
		X0 = (par[0]+par[1])*.5;
		Y0 = (par[2]+par[3])*.5;
		ell_X = 0.15;
		ell_Y = 0.15;
		rot_Z = 0.;
	}
	if (ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[l] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

///////////////////////////
//...solving of the probem;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 200;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);

		sm->shapes_init(NO_STATE); 
		BMM_solver pBMM = {& sm->solver, sm, MAPPING_COUNTING};
//		AbstractSolver		(& pBMM, 
		AbstractParSolver (& pBMM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks, Blocks_Partitioning, 
								Blocks_Sparsity, Blocks_Row, 
								Right_Handside, Initial_Guess, Store_Solution);
		sm->shapes_init(OK_STATE); 
	}
#endif	

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double K[12], E0, nu, mu, C0, lm, ff_vol; memset(K, 0, 12*sizeof(double));
		sm->GetRigidy(K);

		C0 = (K[0]-2.*K[2]*K[5]/(K[5]+K[3]))/(K[3]-2.*K[5]*K[5]/(K[5]+K[3]));
		lm = (K[2]-C0*K[5])/(K[5]+K[3]);
		E0 = (C0-lm)*(C0+2.*lm)/(C0+lm);
		nu = lm/(C0+lm);
		mu = K[7]/(K[10]*2.);
		ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

		FILE  * TST = fopen("box2D_ell_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  E0 = %g  mu = %g  nu = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol, E0, mu, nu, ell_X, ell_Y, rot_Z, E2, E1, nju2, nju1);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			CGrid * nd = CreateNodes();
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(par[0]+.5*i/NX*(par[1]-par[0]));
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(par[2]+.5*j/NY*(par[3]-par[2]));

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			system("del *.grd");
			sm->GetSurferFormat("bb",	 nd,					ERR_VALUE);
			sm->GetSurferFormat("rr",	 nd,				 DISPL_VALUE);
			sm->GetSurferFormat("tf_x", nd,			 STRESS_X_VALUE);
			sm->GetSurferFormat("tt_x", nd, STRESS_X_CLASSIC_VALUE);
			
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_CCOHES2D_CONSTRUCTION_FROM_FEMAP
{
///////////////////////////
//...parameters of problem;
	//char * name = "./Box2d_fulleren/box2D_without15.nas";  
	//char * name = "./Box2d_fulleren/box2D_sph_40.nas";     
	//char * name = "./Box2d_fulleren/box2D_ell70_35_min.nas";
	//char * name = "./Box2d_fulleren/box2D_sph40_min.nas";  
	//char * name = "./Box2d_fulleren/box2D_ell_50_20.dat";  

///////////////////////
//...for homogenizaton;
	//char * name = "./Box2d_homog/sph_04_272.nas";  
	//char * name = "./Box2d_homog/sph_035_192.nas"; 
	//char * name = "./Box2d_homog/sph_03_280.nas";  
	//char * name = "./Box2d_homog/sph_025_64.nas";  
	//char * name = "./Box2d_homog/sph_025_52.nas";  
	//char * name = "./Box2d_homog/sph_025_52a.nas"; 
	//char * name = "./Box2d_homog/sph_025_24.nas";  
	//char * name = "./Box2d_homog/sph_025_16.nas";  
	//char * name = "./Box2d_homog/sph_025_80.nas";  
	//char * name = "./Box2d_homog/sph_025_118.nas"; 
	//char * name = "./Box2d_homog/sph_025_136.nas"; 
	//char * name = "./Box2d_homog/sph_02_40.nas";   
	//char * name = "./Box2d_homog/sph_015_88.nas";  
	//char * name = "./Box2d_homog/sph_01_104.nas";  
	//char * name = "./Box2d_homog/sph_035682_76.nas";
	//char * name = "./Box2d_homog/sph_035682_40_104.nas"; 
	//char * name = "./Box2d_homog/sph_035682_100_156.nas";
	//char * name = "./Box2d_homog/sph_035682_100_184.nas";

/////////////////////////
//...rotation of ellipse;
	//char * name = "./Box2d_homog/ell_rot90_76.nas"; 
	//char * name = "./Box2d_homog/ell_50_20.nas";
	//char * name = "./Box2d_homog/ell_80_20_(equi_circ)_52.nas";
	//char * name = "./Box2d_homog/sph_04_272.nas";
	//char * name = "./Box2d_homog/sph_035682_100_184.nas";

////////////////////////
//...periodically holes;
	//char * name = "./Box2d_homog/hole_sph_025_36.nas";
	//char * name = "./Box2d_homog/hole_sph_03_204.nas";
	//char * name = "./Box2d_homog/hole_sph_01_96.nas";

	//char * name = "./Box2d_homog/layer285_03.nas";
	//char * name = "./Box2d_homog/sph285_03.nas";  
	//char * name = "./Box2d_homog/sph623_01.nas";  
	//char * name = "./Box2d_homog/sph623_02.nas";  

	//char * name = "./Box2d_homog/sph319_04_i.nas";  
	//char * name = "./Box2d_homog/sph623_04_i.nas";  
	//char * name = "./Box2d_homog/sph894_04_i.nas";  
	//char * name = "./Box2d_homog/sph1385_04_i.nas"; 

	//char * name = "./Box2d_homog/sph285_01_i.nas";
	//char * name = "./Box2d_homog/sph285_03_i.nas";
	//char * name = "./Box2d_homog/sph285_02a.nas"; 

	//char * name = "./Box2d_homog/ell_80_20_(200_80).nas";
	char * name = "./Box2d_homog/ell_80_20_i.nas";
	//char * name = "./Box2d_homog/ell_20_80_i.nas";
	//char * name = "./Box2d_homog/ell_80_20q1.nas";
	//char * name = "./Box2d_homog/sph_025_114.nas";  

	//char * name = "./Demo_Sheffild/sph_01_i_112.nas";
	//char * name = "./Box2d_homog/sph285_01.inp";

/////////////////////////////
//...\E7\E0\E4\E0\E5\EC \EF\E0\F0\E0\EC\E5\F2\F0\FB \E7\E0\E4\E0\F7\E8;
	double energy[] = {0., 0.}, EYoung, 
			 nj1		= 0.39, //...matrix parameters; 
			 nj2		= 0.20, //...inclusion parameters; 
			 G1		= 3.41/(1.+nj1)*.5,  //...matrix parameters;
			 G2		= 87.5/(1.+nj2)*.5,  //...inclusion parameters;
			 l0		= 0.01, //...interphase layer as ration sqrt(G1/C1);
			 l2		= 0.06, //...interphase layer as ration sqrt(G2/C2);
			 l0ini	= l0, ff;

	char * pchar, buff[2001]; strcpy(buff, name);
	if ((pchar = strrchr(buff, '.')) != NULL) {
		strcpy(pchar, ".dat");
	}
	FILE * TST = fopen("Effecive.dat", "w");

//	for (int N0 = 5, k = 11; k < 200; k++) {
//		if (k < 11) G2  = k*.1; else
//		if (k < 19) G2  = k-9.; 
//		else			G2  = 10.+(k-19.)*10.; 
//		G2  = 10.;

	for (int N0 = 5, k = 50; k <= 50; k++) {
			 ff = k/100.;
			 l0 = l2 = 2.0;

	//for (int N0 = 3, k = 0; k < 1; k++) {
		memset(energy, 0, 2*sizeof(double));
		EYoung = CIdent(name, ff, 1.0, energy, l0, l2, G1, G2, nj1, nj2, 0.*G1*(1.-nj1)/(.5-nj1)*8., 0.*G1*8., N0, OK_STATE, OK_STATE, OK_STATE);
		fprintf(TST, "ff = %g  EYoung = %g\n", ff, EYoung);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_GRADIENT2D_FROM_FEMAP
{
	char * name_ini = "./Models_inp/Box2D_circle/Box2D_circle_40_M208.inp";
	extern int gradient_model; gradient_model = 0;

	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	int  i, j, l, id_reading = 1;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(MINDL2D_DRAFT, 8);
	sm->set_mpls(PackInts(3, 3)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(16, 8)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);
	sm->set_lagrange(1e5);
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);

///////////////////////////
//...parameters of problem;
	double nju1 = 0.33,					//...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.16,					//...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 E1   = 210.,					//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 420.,					//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 AA	= E1*.0,					//...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 0.3568*3.,			//...interphase layer for matrix;
			 l2	= 0.3568,				//...interphase layer for inclusion;
			 l1_dop	= 0.,					//...interphase layer_dop;
			 l2_dop	= 0.,					//...interphase layer_dop;
			 c0	= 0.40,					//...volume fraction; 
			 G1, G2, KH, GH, EH, nH;
	sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, l1, l1_dop = l1_dop/sqrt(1.-2.*nju1), l2, l2_dop = l2_dop/sqrt(1.-2.*nju2), AA, BB);

///////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name_ini);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name_ini);
      sm->bar_condit_in(name_ini);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	double par[6];	sm->SetGeomBounding(par);
	if (! id_reading) {
		X0 = (par[0]+par[1])*.5;
		Y0 = (par[2]+par[3])*.5;
		ell_X = 0.15;
		ell_Y = 0.15;
		rot_Z = 0.;
	}
	if (ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[l] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

///////////////////////////
//...solving of the probem;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 200;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);

		sm->shapes_init(NO_STATE); 
		BMM_solver pBMM = {& sm->solver, sm, MAPPING_COMPUT};
//		AbstractSolver		(& pBMM, 
		AbstractParSolver (& pBMM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks, Blocks_Partitioning, 
								Blocks_Sparsity, Blocks_Row, 
								Right_Handside, Initial_Guess, Store_Solution);
		sm->shapes_init(OK_STATE); 
	}
#endif	

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double K[16], ku1, lm1, mu1, ku2, lm2, mu2, Ez, Kxy, Gxy, Gxz, nxz, ff_vol; memset(K, 0, 16*sizeof(double));
		sm->GetRigidy(K);
		ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

///////////////////////
//...\EC\E0\F2\F0\E8\F6\E0 \E6\E5\F1\F2\EA\EE\F1\F2\E8;
		ku1 = K[0];
		lm1 = K[2];
		mu1 = K[7];
		ku2 = K[14]*G1*(1.-nju1)/(.5-nju1)+K[15]*G2*(1.-nju2)/(.5-nju2)+
				(G2*nju2/(.5-nju2)-G1*nju1/(.5-nju1))/(G2/(1.-2.*nju2)-G1/(1.-2.*nju1))*
				(K[12]-K[14]*G1*nju1/(.5-nju1)-K[15]*G2*nju2/(.5-nju2));
		lm2 = K[14]*G1*nju1/(.5-nju1)+K[15]*G2*nju2/(.5-nju2)+
				(G2*nju2/(.5-nju2)-G1*nju1/(.5-nju1))/(G2/(1.-2.*nju2)-G1/(1.-2.*nju1))*
				(K[13]-K[14]*G1/(1.-2.*nju1)-K[15]*G2/(1.-2.*nju2));
		mu2 = K[14]*G1+K[15]*G2;

///////////////////////////
//...\F2\E5\F5\ED\E8\F7\E5\F1\EA\E8\E5 \EA\EE\ED\F1\F2\E0\ED\F2\FB;
		nxz = lm2/(ku1+lm1);
		Kxy = 0.5*(ku1+lm1);	
		Gxy = 0.5*(ku1-lm1);	
		Gxz = mu2;	
		Ez  = ku2-2.*lm2*nxz;

///////////////////////////////////////////////////////////////////
//...\F0\E5\E7\F3\EB\FC\F2\E0\F2 \EF\F0\EE\F1\F2\F0\E0\ED\F1\F2\E2\E5\ED\ED\EE\E3\EE \EE\F1\F0\E5\E4\ED\E5\ED\E8\FF \E2\EE\EB\EE\EA\EE\ED \EF\EE \CA\F0\E8\F1\F2\E5\ED\F1\E5\ED\F3;
		KH = (Ez+4.*sqr(1.+nxz)*Kxy)/9.;
		GH = (Ez+sqr(1.-2.*nxz)*Kxy+6.*(Gxy+Gxz))/15.;
		nH = 1./(2.*(Ez+Gxy+Gxz)+(8.*sqr(nxz)+12.*nxz+7.)*Kxy);
		EH = 5.*GH*nH*(Ez+4.*sqr(1.-nxz)*Kxy);
		nH = .5*nH*(Ez+2.*(2.*sqr(nxz)+8.*nxz+3.)*Kxy-4.*(Gxy+Gxz));

		FILE  * TST = fopen("box2D_cyl_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  KH = %g  GH = %g  EH = %g  nH = %g  Ez = %g  Kxy = %g  Gxy = %g  Gxz = %g  nxz = %g  mu1 = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol, KH, GH, EH, nH, Ez, Kxy, Gxy, Gxz, nxz, mu1, ell_X, ell_Y, rot_Z, E2, E1, nju2, nju1);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			CGrid * nd = CreateNodes();
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(par[0]+.5*i/NX*(par[1]-par[0]));
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(par[2]+.5*j/NY*(par[3]-par[2]));

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			system("del *.grd");
			sm->GetSurferFormat("bb",	 nd,					ERR_VALUE);
			sm->GetSurferFormat("rr",	 nd,				 DISPL_VALUE);
			sm->GetSurferFormat("tf_x", nd,			 STRESS_X_VALUE);
			sm->GetSurferFormat("tt_x", nd, STRESS_X_CLASSIC_VALUE);
			
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_LAME3D_SPHEROID
{
	double RR = 1., rr = 0.7, AA = 3.;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(LAME3D_DRAFT, 8);
	sm->set_mpls(PackInts(11, 1)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(8, 4)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);			//...\ED\EE\F0\EC\E8\F0\F3\FE\F9\E8\E9 \EC\ED\EE\E6\E8\F2\E5\EB\FC;
	sm->change_solv(/*SPECIAL_SOLVING*/);
	sm->solver.set_mode(/*REDUCED_PRINT*//*PRINT_MODE*//*FULLY_MODE*/);

//////////////////////
//...\EF\E0\F0\E0\EC\E5\F2\F0\FB \E7\E0\E4\E0\F7\E8;
	double nj1 = 0.30, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0; 
			 nj2 = 0.30, //...\E3\F0\E0\F4\E8\F2\EE\E2\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5; 
			 E1  = 0.135,
			 E2  = 1.5, par[6]; 
	sm->set_fasa_hmg(RR, rr, nj2, nj1, nj1, E2/(1.+nj2)*.5, E1/(1.+nj1)*.5, E1/(1.+nj1)*.5);

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	for (int j = 1; j <= 1; j++) {
///////////////////////
//...\E3\E5\EE\EC\E5\F2\F0\E8\FF \EE\E1\EB\E0\F1\F2\E8;
		sm->GetSpheroidBoxStruct(AA, AA, AA, RR, rr); sm->B[1].type = ESHE_ZOOM_BLOCK;
		par[0] = -AA*.5; par[2] = -AA*.5; par[4] = -AA*.5;
		par[1] =  AA*.5; par[3] =  AA*.5; par[5] =  AA*.5;

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(ESHELBY_COMPUT) != OK_STATE) {
			Message("Error in sample counting...");
			delete sm;
			goto err;
		}
	}

//////////////////
//..visualization;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		int NX = 100, NY = 100, axis = AXIS_Y, alpha = 0, i, j;

		if (axis == AXIS_Z) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_Y) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

			nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_X) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

			nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		for (i = 0; i < nd->N;  i++)
		for (j = 0; j < nd->N1; j++) {
			double X, Y, Z;
			if (axis == AXIS_Z) {
				X = nd->X[i]; Y = nd->Y[j]; Z = nd->Z[0];
			}
			else
			if (axis == AXIS_Y) {
				X = nd->Y[j]; Y = nd->Z[0]; Z = nd->X[i];
			}
			else
			if (axis == AXIS_X) {
				X = nd->Z[0]; Y = nd->X[i]; Z = nd->Y[j];
			}
			if (RR == 0. || rr == 0.) nd->hit[i+j*nd->N] = 0; else
			if (sqr(X/rr)+sqr(Y/rr)+sqr(Z/RR) < 1.) nd->hit[i+j*nd->N] = 0; 
			else	nd->hit[i+j*nd->N] = 1;	
		}

		system("del *.grd");
		sm->GetSurferFormat("rz", nd,	DISPL_ESHE_VALUE, 0, axis);
		sm->GetSurferFormat("tz", nd, STRESS_Z_ESHE_VALUE, 0, axis);

		delete nd;
	}
	delete sm;
}
#endif
#ifdef DRAFT_LAME_ESHELBY_NONLINEAR_DIAGRAM
{
double glina[][2] = {{0.4506, 9.727 },{0.5719,10.2481},{0.7106,10.9429},{0.8492,11.6377},{0.9705,12.5062},{1.0745,13.201 },{1.1958,13.7221},{1.3345,14.4169},{1.5078,15.4591},
							{1.6464,16.1538},{1.7504,16.8486},{1.8718,17.5434},{2.1144,18.933 },{2.2704,19.6278},{2.513 ,20.8437},{2.6516,21.5385},
							{2.7903,22.4069},{3.0503,23.6228},{3.1716,24.3176},{3.2929,24.8387},{3.4315,25.5335},{3.5529,26.2283},{3.6915,26.9231},{3.8302,27.4442},
							{3.9341,28.139 },{4.0728,28.8337},{4.2114,29.3548},{4.3501,30.0496},{4.6447,31.2655},{4.8007,31.9603},{4.9393,32.4814},
							{5.0607,32.8288},{5.2166,33.5236},{5.338 ,34.0447},{5.4766,34.5658},{5.6153,35.0868},{5.7366,35.6079},{5.8925,36.3027},{6.1352,37.1712},
							{6.2738,37.5186},{6.4298,38.0397},{6.7244,39.0819},{6.8631,39.603 },{7.0191,39.9504},{7.1577,40.2978},{7.2964,40.8189},
							{7.6256,41.861 },{7.7816,42.3821},{7.9203,42.7295},{8.0589,43.0769},{8.2496,43.4243},{8.3882,43.7717},{8.5442,44.1191},{8.7002,44.6402},{8.8562,44.9876},
							{8.9775,45.335 },{9.1681,45.8561},{9.3241,46.2035},{9.4801,46.5509}};//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \EC\EE\E4\F3\EB\FF \DE\ED\E3\E0 \E2 MPa;
int N_glina = 59;

double dural[][2] = {{20.,72.},{100.,63.5},{350.,48.}}, //...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \EC\EE\E4\F3\EB\FF \DE\ED\E3\E0 \E2 GPa, \F2\E5\EC\EF\E5\F0\E0\F2\F3\F0\E0 \E2 C;
					A  = ((dural[0][1]-dural[1][1])/(dural[0][0]-dural[1][0])-(dural[0][1]-dural[2][1])/(dural[0][0]-dural[2][0]))/(dural[1][0]-dural[2][0]), 
					B  =  (dural[0][1]-dural[1][1])/(dural[0][0]-dural[1][0])-(dural[0][0]+dural[1][0])*A, 
					C  =   dural[0][1]-dural[0][0]*B-dural[0][0]*dural[0][0]*A;//...\EA\E2\E0\E4\F0\E0\F2\E8\F7\ED\E0\FF \E0\EF\EF\F0\EE\EA\F1\E8\EC\E0\F6\E8\FF;
int N_dural = 3;

double spinel[][2] = {{20.,250.},{350.,440.}};//...C/GPa;
int N_spinel = 2;
//////////////////
//...initial data;
	double nju1 = 0.36, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.16, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 nju3 = 0.30, //...\EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\FB\E9 \F1\EB\EE\E9;  
			 E1   = 1.0,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 380., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 E3   = 1.0,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 K1   = E1/(3.*(1.-2.*nju1)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 K2   = E2/(3.*(1.-2.*nju2)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 K3   = E3/(3.*(1.-2.*nju3)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 G1   = E1/(2.*(1.+nju1)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 G2   = E2/(2.*(1.+nju2)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 G3   = E3/(2.*(1.+nju3)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 l1   = 0.15,			//...\E4\EE\EB\FF \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF \EF\EE \EE\F2\ED\EE\F8\E5\ED\E8\FE \EA \F0\E0\E4\E8\F3\F1\F3 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 c0   = 0.60,			//...volume fraction of inclusion; 
			 c1   = l1*(l1+2.),	//...volume fraction of interface layer; 
			 T0   = 20.0,			//...\ED\E0\F7\E0\EB\FC\ED\E0\FF \F2\E5\EC\EF\E5\F0\E0\F2\F3\F0\E0 \F1\F0\E5\E4\FB;
			 KS, KC, KH, LH, nn, nc, ns, K_min, K_max, ES, EC, EH, GS, GC, GH, E_min, E_max, G_min, G_max;
/////////////////////
//...\E4\E0\ED\ED\FB\E5 \EF\EE \F1\EB\EE\FF\EC;
	const int N = 3;
	double ff[N] = {c0, c1, 1.-c1-c0}, kv[N] = {K2, K3, K1},
			 mu[N] = {G2, G3, G1}, nj[N] = {nju2, nju3, nju1}, ee[N] = {E2, E3, E1},
			 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	//const int N = 2;
	//double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("homog_KK.dat", "w");
	FILE * TSE = fopen("homog_EE.dat", "w");
	for (int j = 20; j <= 350; j += 1) {
		T0 = j*.001*1000.; 
		//E1 = table_approx(T0, glina, N_glina)*0.001;
		E1 = ee[2] = C+(B+A*T0)*T0;
		E3 = ee[1] = table_approx(T0, spinel, N_spinel);
		kv[1] = K3 = E3/(3.*(1.-2.*nju3));
		kv[2] = K1 = E1/(3.*(1.-2.*nju1));
		mu[1] = G3 = E3/(2.*(1.+nju3));
		mu[2] = G1 = E1/(2.*(1.+nju1));
		kp[1] = G3/(1.-2.*nju3);
		kp[2] = G1/(1.-2.*nju1);
		kk[1] = E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3));
		kk[2] = E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1));
		lm[1] = G3*2.*nju3/(1.-2.*nju3);
		lm[2] = G1*2.*nju1/(1.-2.*nju1);

		KS = TakeSphere_KH(N, ff, kv, mu); 
		GS = TakeSphere_GH(N, ff, kv, mu, nj); 
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));
		ns = (1.5*KS-fabs(GS))/(3.*KS+fabs(GS));

		KC = TakeCylinder_KH(N, ff, kp, mu); 
		GC = TakeCylinder_GH(N, ff, kp, mu, nj); 
		EC = fabs(GC)*(3.*KC-fabs(GC))/KC;
		nc = (1.-fabs(GC)/KC)*.5;

		KH = TakeCylinder_EH(N, ff, kk);	//...\F4\EE\F0\EC\F3\EB\E0 \F1\EC\E5\F1\E8, \E4\EE\EF\EE\EB\ED\E8\F2\E5\EB\FC\ED\FB\E5 \F5\E0\F0\E0\EA\F2\E5\F0\E8\F1\F2\E8\EA\E8 \E2 \F6\E8\EB\E8\ED\E4\F0\E8\F7\E5\F1\EA\EE\E9 \F1\E8\EC\EC\E5\F2\F0\E8\E8; 
		EH = TakeCylinder_EH(N, ff, ee);	//...\F4\EE\F0\EC\F3\EB\E0 \F1\EC\E5\F1\E8; 
		LH = TakeCylinder_LH(N, ff, lm, mu, nj);
		GH = TakeCylinder_GH(N, ff, mu, nj); //...\EF\F0\EE\E4\EE\EB\FC\ED\FB\E9 \EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0; 
		nn = LH/(LH+KH);

		K_min = 1./(c0/K2+(1.-c0)/K1);
		K_max = c0*K2+(1.-c0)*K1;
		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;
		G_min = 1./(c0/G2+(1.-c0)/G1);
		G_max = c0*G2+(1.-c0)*G1;

  		fprintf(TST, " c0 = %g, l1 = %g, T0 = %g, KS = %g, KC = %g, KH = %g, LH = %g, GH = %g, K_min = %g, K_max = %g\n", c0, l1, T0, KS, KC, KH, LH, GH, K_min, K_max);
  		fprintf(TSE, " c0 = %g, l1 = %g, T0 = %g, ES = %g, EC = %g, EH = %g, ns = %g, nc = %g, nn = %g, E_min = %g, E_max = %g, G_min = %g, G_max = %g\n", c0, l1, T0, ES, EC, EH, ns, nc, nn, E_min, E_max, G_min, G_max);
	}
	fclose(TST);
	fclose(TSE);
}
#endif
#ifdef DRAFT_LAME_ESHELBY_COMPARISON_DIAGRAM
{
//////////////////
//...initial data;
	double nju1 = 0.48, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.30, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 E1   = 1.0,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 20.0, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 K1   = E1/(3.*(1.-2.*nju1)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 K2   = E2/(3.*(1.-2.*nju2)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 G1   = E1/(2.*(1.+nju1)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 G2   = E2/(2.*(1.+nju2)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 l1   = 0.10, //...\E4\EE\EB\FF \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF \E2\EE \E2\EA\EB\FE\F7\E5\ED\E8\E8;
			 l2   = 0.10, //...\E4\EE\EB\FF \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF \EF\EE \EE\F2\ED\EE\F8\E5\ED\E8\FE \EA \F0\E0\E4\E8\F3\F1\F3 \E2\EA\EB\FE\F7\E5\ED\E8\FF \E2 \EC\E0\F2\F0\E8\F6\E5;
			 c0   = 0.10, //...volume fraction of inclusion; 
			 KS, KH, K0, ES, EH, E0, GS, GH, G0, ns, nn, n0, K_min, K_max, E_min, E_max, G_min, G_max;

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("homog_EE.dat", "w");
	for (int j = 1; j < 400; j += 1) {
		l2 = 0.066+j*.00001;

		KS = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, l1, l2);
		GS = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, l1, l2);
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));
		ns = (1.5*KS-fabs(GS))/(3.*KS+fabs(GS));
		
		KH = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, l1, l2);
		GH = TakeSphere_shear_two(c0, nju1, nju2, E1, E2, l1, l2);
		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		nn = (1.5*KH-fabs(GH))/(3.*KH+fabs(GH));
		
		K0 = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, 0., 0.);
		G0 = TakeSphere_shear_two(c0, nju1, nju2, E1, E2, 0., 0.);
		E0 = 9.*K0*fabs(G0)/(3.*K0+fabs(G0));
		n0 = (1.5*K0-fabs(G0))/(3.*K0+fabs(G0));
		
		K_min = 1./(c0/K2+(1.-c0)/K1);
		K_max = c0*K2+(1.-c0)*K1;
		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;
		G_min = 1./(c0/G2+(1.-c0)/G1);
		G_max = c0*G2+(1.-c0)*G1;

  		//fprintf(TST, " c0 = %g, l1 = %g, l2 = %g, KS = %g, KH = %g, K0 = %g, ES = %g, EH = %g, E0 = %g, GS = %g, GH = %g, G0 = %g, KI = %g, KM = %g\n", 
				//			c0, l1, l2, KS, KH, K0, ES, EH, E0, GS, GH, G0, K2, K1);
  		//fprintf(TST, " c0 = %g, l1 = %g, l2 = %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, KI = %g, KM = %g\n", 
				//			c0, l1, l2, KS, KH, K0, ES, EH, E0, GS, GH, G0, K2, K1);
  		fprintf(TST, " %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", l2, KS, KH, K0, ES, EH, E0, GS, GH, G0);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE
{
//////////////////
//...initial data;
	double nju1 = 0.40, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.22, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 nju3 = 0.30, //...\EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\FB\E9 \F1\EB\EE\E9;  
			 E1   = 1.0,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 12.,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 E3   = 1.0,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 al1  = 0.001,//...KTE \EC\E0\F2\F0\E8\F6\FB;
			 al2  = 0.010,//...KTE \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 al3  = 0.0,  //...KTE \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 K1   = E1/(3.*(1.-2.*nju1)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 K2   = E2/(3.*(1.-2.*nju2)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 K3   = E3/(3.*(1.-2.*nju3)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 G1   = E1/(2.*(1.+nju1)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 G2   = E2/(2.*(1.+nju2)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 G3   = E3/(2.*(1.+nju3)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 l1	= 0.1,   //...interphase layer for matrix;
			 l2	= 0.03,  //...interphase layer for inclusion;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction; 
			 GH = 0., GL, GS, GC, G0, G_min, G_max, KH, KL, KS, KC, K0, KK, K_min, K_max, EH, EL, ES, EC, E0, E_min, E_max, LH, L_min, L_max, nn;
/////////////////////
//...\E4\E0\ED\ED\FB\E5 \EF\EE \F1\EB\EE\FF\EC;
	//const int N = 3;
	//double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
	//		 mu[N] = {G2, G3, G1}, ll[N] = {l2, 0., l1}, nj[N] = {nju2, nju3, nju1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	const int N = 2;
	double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
			 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("homog_KK.dat", "w");
	FILE * TSG = fopen("homog_GG.dat", "w");
	FILE * TSE = fopen("homog_EE.dat", "w");
	for (int j = 1; j < 1000; j += 1) {
		c0 = j*.001; 
		//l1 = j*.001*limit;
		
		//ff[0] = c0*.8; ff[1] = c0*.2; ff[2] = 1.-c0; ll[0] = l1;
		ff[0] = c0; ff[1] = 1.-c0; ll[0] = l1;
		E_min = TakeLayer_EH(N, ff, kk, NULL);
		KL = TakeLayer_EH(N, ff, kk, ll);
		GL = TakeLayer_EH(N, ff, mu, ll);
		EL = (3.*KL-4.*fabs(GL))*fabs(GL)/(KL-fabs(GL));
		E_max = TakeCylinder_EH(N, ff, kk);

		KH = TakeCylinder_EH(N, ff, kk); 
		KC = TakeCylinder_KH(N, ff, kp, mu); 
		KK = kp[1]+ff[0]*(kp[0]-kp[1])/(1.+ff[1]*(kp[0]-kp[1])/(kp[1]+mu[1]));
		GC = TakeCylinder_GH(N, ff, kp, mu, nj); 
		EC = fabs(GC)*(3.*KC-fabs(GC))/KC;
		LH = TakeCylinder_LH(N, ff, lm, mu, nj);
		KK = lm[1]+ff[0]*(lm[0]-lm[1])/(1.+ff[1]*(kp[0]-kp[1])/(kp[1]+mu[1]));
		nn = LH/(LH+KH);
		GH = TakeCylinder_EH(N, ff, mu); 
		GH = TakeCylinder_GH(N, ff, mu, nj); 

		KS = TakeSphere_KH(N, ff, kv, mu); 
		GS = TakeSphere_GH(N, ff, kv, mu, nj); 
		G0 = TakeSphere_GH_det(c0, nju1, nju2, E1, E2); 
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));
		KK = kv[1]+ff[0]*(kv[0]-kv[1])/(1.+ff[1]*(kv[0]-kv[1])/(kv[1]+4./3.*mu[1]));

		K_min = 1./(c0/K2+(1.-c0)/K1);
		K_max = c0*K2+(1.-c0)*K1;

		G_min = 1./(c0/G2+(1.-c0)/G1);
		G_max = c0*G2+(1.-c0)*G1;

		KH = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, l1, l2);
		GH = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, l1, l2);
		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		//KH = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, l1, l2);
		//GH = TakeSphere_shear_two(c0, nju1, nju2, E1, E2, l1, l2);

		K0 = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, 0., 0.);
		G0 = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, 0., 0.);
		E0 = 9.*K0*G0/(3.*K0+G0);

		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;

  		fprintf(TST, " c0 = %g, KL = %g, KC = %g, KS = %g, KH = %g, K0 = %g, K_min = %g, K_max = %g\n", c0, KL, KC, KS, KH, K0, K_min, K_max);
  		fprintf(TSG, " c0 = %g, GL = %g, GC = %g, GS = %g, GH = %g, G0 = %g, G_min = %g, G_max = %g\n", c0, GL, GC, GS, GH, G0, G_min, G_max);
  		fprintf(TSE, " c0 = %g, EL = %g, EC = %g, ES = %g, EH = %g, E0 = %g, E_min = %g, E_max = %g, LH = %g, nn = %g\n", c0, EL, EC, ES, EH, E0, E_min, E_max, LH, nn);
	}
	fclose(TST);
	fclose(TSG);
	fclose(TSE);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_sph
{
//////////////////
//...initial data;
	double nju1 = 0.165,//...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.12,//...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 nju3 = 0.30,//...\EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\FB\E9 \F1\EB\EE\E9;  
			 E1   = 73., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 480.,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 E3   = 1.0, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 al1  = 0.001,//...KTE \EC\E0\F2\F0\E8\F6\FB;
			 al2  = 0.010,//...KTE \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 al3  = 0.0,  //...KTE \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 K1   = E1/(3.*(1.-2.*nju1)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 K2   = E2/(3.*(1.-2.*nju2)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 K3   = E3/(3.*(1.-2.*nju3)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 G1   = E1/(2.*(1.+nju1)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 G2   = E2/(2.*(1.+nju2)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 G3   = E3/(2.*(1.+nju3)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 //l1	= 0.1,   //...interphase layer for matrix;
			 //l2	= 0.03,  //...interphase layer for inclusion;
			 l1	= 10.00,    //...interphase layer for matrix;
			 l2	= -0.03,    //...interphase layer for inclusion;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction; 
			 GH = 0., GS, G0, KH, KS, K0, EH, ES, E0, E_min, E_max;
/////////////////////
//...\E4\E0\ED\ED\FB\E5 \EF\EE \F1\EB\EE\FF\EC;
	//const int N = 3;
	//double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
	//		 mu[N] = {G2, G3, G1}, ll[N] = {l2, 0., l1}, nj[N] = {nju2, nju3, nju1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	const int N = 2;
	double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
			 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("homog_ALL.dat", "w");
	for (int j = 0; j <= 1000; j += 1) {
		c0 = j*.001; 
		//l1 = j*.001*limit;
		//ff[0] = c0*.8; ff[1] = c0*.2; ff[2] = 1.-c0; ll[0] = l1;

		ff[0] = c0; ff[1] = 1.-c0; ll[0] = l1;
		KH = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, l1, l2);
		GH = TakeSphere_shear	 (c0, nju1, nju2, E1, E2, l1, l2);
		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));

		KS = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, l1, l2);
		GS = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, l1, l2);
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));

		K0 = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, 0., 0.);
		G0 = TakeSphere_shear    (c0, nju1, nju2, E1, E2, 0., 0.);
		E0 = 9.*K0*G0/(3.*K0+G0);

		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;

  		fprintf(TST, " c0 = %g, EH = %g, GH = %g, KH = %g, ES = %g, GS = %g, KS = %g, E0 = %g, G0 = %g, K0 = %g, E_min = %g, E_max = %g\n", c0, EH, GH, KH, ES, GS, KS, E0, G0, K0, E_min, E_max);
  		//fprintf(TST, " c0 = %g, GH = %g, GS = %g, G0 = %g\n", c0, GH, GS, G0);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_cyl
{
//////////////////
//...initial data;
	double nju1 = 0.32, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.17, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 nju3 = 0.30, //...\EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\FB\E9 \F1\EB\EE\E9;  
			 E1   = 1.25, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 3900., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 E3   = 60.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 al1  = 0.001,//...KTE \EC\E0\F2\F0\E8\F6\FB;
			 al2  = 0.010,//...KTE \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 al3  = 0.0,  //...KTE \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 K1   = E1/(3.*(1.-2.*nju1)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 K2   = E2/(3.*(1.-2.*nju2)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 K3   = E3/(3.*(1.-2.*nju3)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 G1   = E1/(2.*(1.+nju1)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 G2   = E2/(2.*(1.+nju2)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 G3   = E3/(2.*(1.+nju3)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 l0	= 0.6,   //...\EE\F2\ED\EE\F1\E8\F2\E5\EB\FC\ED\E0\FF \F8\E8\F0\E8\ED\E0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF;
			 l1	= 0.1,   //...interphase layer for matrix;
			 l2	= 0.03,  //...interphase layer for inclusion;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction; 
			 GH = 0., GG, G0, KH, KK, LH, EH, nu_H, nH;
/////////////////////
//...\E4\E0\ED\ED\FB\E5 \EF\EE \F1\EB\EE\FF\EC;
	//const int N = 3;
	//double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
	//		 mu[N] = {G2, G3, G1}, ll[N] = {l2, 0., l1}, nj[N] = {nju2, nju3, nju1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	const int N = 2;
	double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
			 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("homog_ALL.dat", "w");
	for (int j = 0; j <= 1000; j += 1) {
		c0 = j*.001;
		//l0 = 1./sqrt(c0)-1.;
		//l1 = j*.001*limit;
		//ff[0] = c0; ff[1] = c0*l0*(l0+2.); ff[2] = 1.-c0-c0*l0*(l0+2.); ll[0] = l1;
		//ff[0] = c0; ff[1] = 0.1*(1.-c0); ff[2] = 0.9*(1.-c0); ll[0] = l1;
		
 		ff[0] = c0; ff[1] = 1.-c0; ll[0] = l1;
		KH = TakeCylinder_KH(N, ff, kp, mu); 
		GH = TakeCylinder_GH(N, ff, kp, mu, nj);
		G0 = TakeCylinder_SH(N, ff, kp, mu, nj);
		nH = (KH-GH)/(2.*KH);
		EH = fabs(GH)*(3*KH-fabs(GH))/KH;
		KK = TakeCylinder_EH(N, ff, kk); 
		LH = TakeCylinder_LH(N, ff, lm, mu, nj);
		GG = TakeCylinder_GH(N, ff, mu, nj);
		nu_H = LH/(2.*KH);
		
  		fprintf(TST, " c0 = %g, EH = %g, KH = %g, GH = %g, G0 = %g, nH = %g, KK = %g, GG = %g, LH = %g, nu_H = %g\n", c0, EH, KH, GH, G0, nH, KK, GG, LH, nu_H);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_layer
{
//////////////////
//...initial data;
	double nju1 = 0.21, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.12, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 nju3 = 0.30, //...\EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\FB\E9 \F1\EB\EE\E9;  
			 E1   = 475., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 480., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 E3   = 57.0, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 al1  = 0.001,//...KTE \EC\E0\F2\F0\E8\F6\FB;
			 al2  = 0.010,//...KTE \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 al3  = 0.0,  //...KTE \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 K1   = E1/(3.*(1.-2.*nju1)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 K2   = E2/(3.*(1.-2.*nju2)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 K3   = E3/(3.*(1.-2.*nju3)),//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 G1   = E1/(2.*(1.+nju1)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 G2   = E2/(2.*(1.+nju2)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 G3   = E3/(2.*(1.+nju3)),   //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\EE\E3\EE \F1\EB\EE\FF;
			 l1	= 1.0,   //...interphase layer for matrix;
			 l2	= 1.0,   //...interphase layer for inclusion;
			 l3	= 1.0,   //...interphase layer for interphase layer;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction of interphase layer; 
			 c1     = 0.30,//...volume fraction of inclusion; 
			 GH = 0., G_min, G_max, KH, K_min, K_max, EH, E_min, E_max;
/////////////////////
//...\E4\E0\ED\ED\FB\E5 \EF\EE \F1\EB\EE\FF\EC;
	const int N = 3;
	double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
			 mu[N] = {G2, G3, G1}, ll[N] = {l2, l3, l1}, nj[N] = {nju2, nju3, nju1}, 
			 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	//const int N = 2;
	//double ff[N] = {c0, 1.-c0}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))};

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("homog_All.dat", "w");
	for (int j = 0; j <= 500; j += 1) {
		c0 = j*.001; 
		//l1 = j*.001*limit;
		
		ff[0] = c1; ff[1] = c0; ff[2] = 1.-c0-c1; ll[0] = l2;
		//ff[0] = c0; ff[1] = 1.-c0; ll[0] = l2;
		KH = TakeLayer_EH(N, ff, kk, ll);
		GH = TakeLayer_EH(N, ff, mu, ll);
		EH = (3.*KH-4.*fabs(GH))*fabs(GH)/(KH-fabs(GH));

		K_min = 1./(c0/kk[0]+(1.-c0)/kk[1]);
		K_max = c0*kk[0]+(1.-c0)*kk[1];

		G_min = 1./(c0/mu[0]+(1.-c0)/mu[1]);
		G_max = c0*mu[0]+(1.-c0)*mu[1];

		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;

  		fprintf(TST, " c0 = %g, KH = %g, K_min = %g, K_max = %g, GH = %g, G_min = %g, G_max = %g, EH = %g, E_min = %g, E_max = %g\n", 
							c0, KH, K_min, K_max, GH, G_min, G_max, EH, E_min, E_max);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(/*MINDL3D_DRAFT*/COHES3D_DRAFT, 8),
						* el = CreateDraft(LAME3D_DRAFT,  8);
	double nju1 = 0.4, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.22, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 K1   = 1.0,  //...\EE\E1\FA\E5\EC\ED\FB\E9 \EC\EE\E4\F3\EB\FC \EC\E0\F2\F0\E8\F6\FB;
			 K2   = 40., //...\EE\E1\FA\E5\EC\ED\FB\E9 \EC\EE\E4\F3\EB\FC \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 //E1   = 3.*(1.-2.*nju1)*K1,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 //E2   = 3.*(1.-2.*nju2)*K2,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 E1   = 1.0,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E0\F2\F0\E8\F6\FB;
			 E2   = 56.,//...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E2\EA\EB\FE\F7\E5\ED\E8\FF;
			 AA	= E1*.0,			 //...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 4.0,   //...interphase layer for matrix;
			 l2	= 0.03,   //...interphase layer for inclusion;
			 l1_dop = 0.,  //...interphase layer_dop;
			 l2_dop = 0.,  //...interphase layer_dop;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.1,//...volume fraction; 
			 G1, G2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0;

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("mindl3D_homog.dat", "w");
	for (int j = 1; j <= 1000; j += 1) {
		//c0 = j*.001;
		l1 = (j*.001)*limit;
		//sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, l1, l1_dop = l1/sqrt(1.-2.*nju1), l2, l2_dop = l2/sqrt(1.-2.*nju2), AA, BB);
		sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, G1/sqr(l1), G2/sqr(l2));
		el->set_fasa_hmg(nju1, nju2, G1, G2);

		KH = sm->TakeEshelby_volm_two (c0);
		GH = sm->TakeEshelby_shear_two(c0);
		//GH = sm->TakeEshelby_shear_det(c0);

		K0 = el->TakeEshelby_volm_two (c0);
		G0 = el->TakeEshelby_shear_two(c0);

		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		E0 = 9.*K0*G0/(3.*K0+G0);

		nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;
		nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

  		fprintf(TST, " l1 = %g,  l1_dop = %g, l2 = %g,  l2_dop = %g, A = %g, B = %g, c0 = %g, KH = %g, K0 = %g, GH = %g, G0 = %g, EH = %g, E0 = %g, nuH = %g, nu0 = %g\n", 
				l1, l1_dop, l2, l2_dop, AA, BB, c0, KH, K0, GH, G0, EH, E0, nuH, nu0);
	}
	fclose (TST);
	delete sm;
	delete el;
}
#endif
#ifdef ESHELBY_CALCULATIONS
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(MINDL3D_DRAFT, 8),
						* el = CreateDraft(LAME3D_DRAFT,  8);
////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - \C2\CF\CC2;
	//double nju1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
	//		 //E1   = 210., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 20\D1;
	//		 //E1   = 150., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 600\D1;
	//		 E1   = 30.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 1400/1300\D1;
	//		 AA	= E1*.0,			 //...adhegion parameter;
	//		 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
	//		 l1	= 15.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 20\D1;
	//		 //l1	= 20.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 600\D1;
 //  		 //l1	= 25.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 1400/1300\D1;
	//		 l1_dop = 0.; //...interphase layer_dop;
///////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - \C2\CA\CD\C0-1\D3;
	double nju1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 //E1   = 150., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 20\D1;
			 //E1   = 135., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 600\D1;
			 E1   = 40.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 1400/1300\D1;
			 AA	= E1*.0,			 //...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 15.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 20\D1;
			 //l1	= 20.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 600\D1;
 			 //l1	= 25.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 1400/1300\D1;
			 l1_dop = 0.; //...interphase layer_dop;
///////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - AL2O3;
	//double nju2 = 0.20, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
	//		 E2   = 380., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa);
	//		 l2	= 0.005,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
	//		 l2_dop	= 0., //...interphase layer_dop;
	//		 rad = 0.05,   //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
	//		 c0  = 0.035,  //...\EF\F0\E5\E4\E5\EB\FC\ED\E0\FF \EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
	//		 G1, G2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ll;
///////////////////////////////////////////////////////////
////...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - Y2O3;
	double nju2 = 0.31, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 //E2   = 225., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 20\D1;
			 //E2   = 215., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 600\D1;
			 E2   = 180.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 1400/1300\D1;
			 l2	= 0.005,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
			 l2_dop	= 0., //...interphase layer_dop;
			 rad = 0.025,   //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
			 c0  = 0.035,  //...\EF\F0\E5\E4\E5\EB\FC\ED\E0\FF \EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
			 G1, G2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ll;

///////////////////////////////  
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("mindl3D_homog.dat", "w");
	for (int j = 0; j <= 500; j += 1) {
		ff = 0.02+j*.00003; ll = 10./*(l1/rad)*/;
	//for (int j = 1; j <= 2000; j += 1) {
	//	ll = (j*.0005)*10.; ff = c0;
		sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, ll, l1_dop = (l1_dop/rad)/sqrt(1.-2.*nju1), (l2/rad), l2_dop = (l2_dop/rad)/sqrt(1.-2.*nju2), AA, BB);
		el->set_fasa_hmg(nju1, nju2, G1, G2);

		KH = sm->TakeEshelby_volm_two (ff);
		GH = sm->TakeEshelby_shear_two(ff);

		K0 = el->TakeEshelby_volm_two (ff);
		G0 = el->TakeEshelby_shear_two(ff);

		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		E0 = 9.*K0*G0/(3.*K0+G0);

		nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;
		nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

  		fprintf(TST, " l1 = %g,  l1_dop = %g, l2 = %g,  l2_dop = %g, A = %g, B = %g, c0 = %g, KH = %g, K0 = %g, GH = %g, G0 = %g, EH = %g, E0 = %g, nuH = %g, nu0 = %g\n", 
				ll, l1_dop, (l2/rad), l2_dop, AA, BB, ff, KH, K0, GH, G0, EH, E0, nuH, nu0);
	}
	fclose (TST);
	delete sm;
	delete el;
}
#endif
#ifdef ALUMO_COMPOSITES_CALCULATIONS
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(COHES3D_DRAFT, 8),
						* el = CreateDraft(LAME3D_DRAFT,  8);
//////////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - \EC\E0\F2\F0\E8\F6\E0 Al;
	//double nju1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
	//		 nju3 = 0.30, //...\EC\E5\E6\F4\E0\E7\ED\FB\E9 \F1\EB\EE\E9;
	//		 E1   = 15.6, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\FF\E3\EA\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 E3   = 57.5, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF (GPa);
	//		 G1   = E1/(1.+nju1)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\FF\E3\EA\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 G3   = E3/(1.+nju3)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF (GPa);
	//		 l1	= 0.2455,  //...\F0\E0\E7\EC\E5\F0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF (\EC\EA\EC, 16.365*0.015);
	//		 eps	= 26.; //...\EF\EE\F0\E8\F1\F2\EE\F1\F2\FC (%);
//////////////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - \EC\E0\F2\F0\E8\F6\E0 Al-B95;
	//double nju1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
	//		 nju3 = 0.30, //...\EC\E5\E6\F4\E0\E7\ED\FB\E9 \F1\EB\EE\E9;
	//		 E1   = 70.0, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\FF\E3\EA\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 G1   = E1/(1.+nju1)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\FF\E3\EA\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 l1	= 0.940, //...\F0\E0\E7\EC\E5\F0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF (\EC\EA\EC);
	//		 rad0 = 0.812, //...\F0\E0\E4\E8\F3\F1 \ED\E0\F7\E0\EB\E0 \EC\E0\F1\F8\F2\E0\E1\ED\EE\E3\EE \FD\F4\F4\E5\EA\F2\E0 (\EC\EA\EC);
	//		 rad1 = 1.00,  //...\F0\E0\E4\E8\F3\F1 \EE\EA\EE\ED\F7\E0\ED\E8\FF \EC\E0\F1\F8\F2\E0\E1\ED\EE\E3\EE \FD\F4\F4\E5\EA\F2\E0 (\EC\EA\EC);
	//		 rad_str	= 5.; //...\F0\E0\E7\EC\E5\F0 \E7\E5\F0\ED\E0 \E2 \F1\F2\F0\F3\EA\F2\F3\F0\E5 (\EC\EA\EC);
///////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - AL2O3;
	//double nju2 = 0.25, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
	//		 E2   = 500., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 l2	= 0.0015,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
	//		 rad = 0.015,   //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
	//		 c0  = 0.0001,  //...\EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
	//		 \D11, \D12, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ff_l, ll, kk;
///////////////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - AL2O3, \EA\EB\E0\F1\F2\E5\F0\FB;
	//double nju2 = 0.24, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
	//		 E2   = 293., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 l2	= 0.05,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
	//		 rad = 0.500,  //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
	//		 c0  = 0.0001,  //...\EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
	//		 \D11, \D12, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ff_l, ll, kk;
/////////////////////////////////////////////////////////////////
//...\E8\F1\F5\EE\E4\ED\FB\E5 \E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - ZrO2;
	//double nju2 = 0.31, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
	//		 E2   = 578.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 l2	= 0.0015, //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
	//		 rad = 0.015,   //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
	//		 c0  = 0.001,   //...\EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \EC\E0\EA\F1\E8\EC\E0\EB\FC\ED\EE\E9 \EA\EB\E0\F1\F2\E5\F0\E8\E7\E0\F6\E8\E8 \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
	//		 \D11, \D12, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ff_l, ll, kk;
////////////////////////////////////////////////////////////////
//...\E8\F1\F5\EE\E4\ED\FB\E5 \E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - SiC;
	//double nju2 = 0.16, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
	//		 E2   = 415.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \EC\E0\F2\F0\E8\F6\FB (GPa);
	//		 l2	= 0.0015, //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
	//		 rad = 0.015,   //...\EF\F0\E5\E4\E5\EB\FC\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
	//		 c0  = 0.300,   //...\EF\F0\E5\E4\E5\EB\FC\ED\E0\FF \EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
	//		 \D11, \D12, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, E_max, ff, ff_l, ll, kk;
///////////////////////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \FD\EF\EE\EA\F1\E8\E4\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - SiO2;
	double nju1 = 0.39, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 nju2 = 0.20, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 E1   = 2.51, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \FD\EF\EE\EA\F1\E8\E4\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
			 E2   = 87.5, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \F1\F2\E5\EA\EB\FF\ED\ED\FB\F5 \F8\E0\F0\E8\EA\EE\E2 (GPa);
			 //E2   = 56.0, //...\E0\EB\FC\F2\E5\F0\ED\E0\F2\E8\E2\ED\FB\E9 \EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \F1\F2\E5\EA\EB\FF\ED\ED\FB\F5 \F8\E0\F0\E8\EA\EE\E2 (GPa);
			 G1   = E1/(1.+nju1)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
			 G2   = E2/(1.+nju2)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa);
			 rad  = 0.015, //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \ED\E0\ED\EE\E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
			 l1	= 0.100, //...\EE\F2\ED\EE\F1\E8\F2\E5\EB\FC\ED\FB\E9 \EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC);
			 l2	= 0.030, //...\EE\F2\ED\EE\F1\E8\F2\E5\EB\FC\ED\FB\E9 \EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
			 c0   = 0.001, //...\EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
			 \D11, \D12, GH = 0., KH, G0, K0, EH, E_min, E_max, nuH, E0, nu0, ff, ff_l, ll, kk;

/////////////////////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\EB\FE\EC\EE\EA\EE\EC\EF\EE\E7\E8\F2\E0 (\F7\E5\F2\FB\F0\E5\F5\F4\E0\E7\ED\E0\FF \EC\EE\E4\E5\EB\FC, \EE\F6\E5\ED\EA\E0 E3);
	//FILE * TST = fopen("Alumo3D_limit.dat", "w");
	//for (int j = 1; j <= 1000; j += 1) {
	//	ff = .0015; ll = l1/0.015; ll = 6.04;
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	E3 = 10+j*.1;
	//	G3   = E3/(1.+nju3)*.5;
	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, " c0 = %g, c1 = %g, l1/rad = %g, E3 = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", ff, ff_l, ll, E3, K0, G0, E0, nu0);
	//}
	//fclose (TST);

///////////////////////////////////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\EB\FE\EC\EE\EA\EE\EC\EF\EE\E7\E8\F2\E0 (\F7\E5\F2\FB\F0\E5\F5\F4\E0\E7\ED\E0\FF \EC\EE\E4\E5\EB\FC, \EE\F6\E5\ED\EA\E0 \F0\E0\E4\E8\F3\F1\E0 \EA\EB\E0\F1\F2\E5\F0\E0);
	//FILE * TST = fopen("Alumo3D_aglom.dat", "w");
	//for (int j = 1; j <= 500; j += 1) {
	//	ff = .001; ll = 3+j*.01;
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, " c0 = %g, c1 = %g, l1/rad = %g, rad = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", ff, ff_l, ll, l1/ll, K0, G0, E0, nu0);
	//}
	//fclose (TST);

//////////////////////////////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\EB\FE\EC\EE\EA\EE\EC\EF\EE\E7\E8\F2\E0 (\F7\E5\F2\FB\F0\E5\F5\F4\E0\E7\ED\E0\FF \EC\EE\E4\E5\EB\FC, \F4\E8\EA\F1\E8\F0\EE\E2\E0\ED\ED\FB\E9 \F1\EB\EE\E9);
	//double table_lrad[][2] = {{0.0001, 16.365},{0.0005, 9.155},{0.0006, 7.60},{0.0007, 6.63},{0.0008, 5.81},{0.0009, 5.10},{0.0010, 4.72},{0.0015, 5.23},{0.0020, 5.4}},
	//		 table_EL  [][2] = {{0.0001,   57.5},{0.0005,  30.3},{0.0006, 30.0},{0.0007, 29.7},{0.0008, 29.4},{0.0009, 29.1},{0.0010, 28.9},{0.0015, 28.9},{0.0020, 28.8}},
	//		 table_rad [][2] = {{0.0001,  0.015},{0.0005,  0.40},{0.0006, 0.42},{0.0007, 0.44},{0.0008, 0.46},{0.0009, 0.48},{0.0010, 0.50},{0.0015, 0.50},{0.0020, 0.50}};
	//int N_table = 9;

	//FILE * TST = fopen("Alumo3D_layer.dat", "w");
	//for (int j = 1; j <= 200; j += 1) {
	//	ff = j*.00001; /*ll = 16.365*sqrt(1.162506)/sqrt(1.+sqr(ff/c0)*(15.607+7.43633*(ff/c0))); 
	//	if (ff > c0) ll = 16.365*sqrt(1.162506)/sqrt(24.04333); rad =l1/(16.365*sqrt(1.162506))*sqrt(24.04333);*/
	//	ll = table_approx(ff, table_lrad, N_table);
	//	E3 = table_approx(ff, table_EL,   N_table);
	//	G3 = E3/(1.+nju3)*.5;
	//	rad = table_approx(ff, table_rad, N_table);
	//	ff_l = ff*(sqr(1+ll)*(1+ll)-1.);

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, " rad = %g, l1/rad = %g, c0 = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", rad/*l1/ll*/, ll, ff, K0, G0, E0, nu0);
	//}
	//fclose (TST);

////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \EA\EE\EC\EF\EE\E7\E8\F2\E0 \EF\EE \E3\F0\E0\E4\E8\E5\ED\F2\ED\EE\E9 \EC\EE\E4\E5\EB\E8;
	FILE * TST = fopen("Alumo3D_grad.dat", "w");
	for (int j = 0; j <= 1000; j += 1) {
		ff = c0*j;
		sm->set_fasa_hmg(nju1, nju2, G1, G2, \D11 = G1/sqr(l1), G2/sqr(l2));

		KH = sm->TakeEshelby_volm_two (ff);
		GH = sm->TakeEshelby_shear_two(ff);

		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;

		E_min = 1./(ff/E2+(1.-ff)/E1);
		E_max = ff*E2+(1.-ff)*E1;

		//fprintf(TST, " l1 = %g, l2 = %g, c0 = %g, KH = %g, GH = %g, EH = %g, E_min = %g, , E_max = %g, , nuH = %g\n", l1, l2, ff, KH, GH, EH, E_min, E_max, nuH);
		fprintf(TST, " %g, %g, %g, %g\n", ff, EH, E_min, E_max);
	}
	fclose (TST);

//////////////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \F5\E0\F0\E0\EA\F2\E5\F0\E0 \ED\E0\F1\FB\F9\E5\ED\E8\FF \EF\EE \E3\F0\E0\E4\E8\E5\ED\F2\ED\EE\E9 \EC\EE\E4\E5\EB\E8;
	//FILE * TST = fopen("Alumo3D_saturat.dat", "w");
	//for (int j = 1; j <= 1000; j += 1) {
	//	ff = c0; ll = l1*j*0.001;
	//	sm->set_fasa_hmg(nju1, nju2, G1, G2, \D11 = G1/sqr(ll), G2/sqr(l2/rad));

	//	KH = sm->TakeEshelby_volm_two (ff);
	//	GH = sm->TakeEshelby_shear_two(ff);

	//	EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
	//	nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;

	//	fprintf(TST, " l1 = %g, l2 = %g, c0 = %g, KH = %g, GH = %g, EH = %g, nuH = %g\n", ll, l2/rad, ff, KH, GH, EH, nuH);
	//}
	//fclose (TST);

///////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\EB\FE\EC\EE\EA\EE\EC\EF\EE\E7\E8\F2\E0;
	//FILE * TST = fopen("Alumo3D_homog.dat", "w");
	//for (int j = 1; j <= 5000; j += 1) {
	//	rad = j*0.002; ll = 1.2/*l1/rad*/; E_max = (1.-c0)*E1+c0*E2; 
	//	//l2 = 1.158; if (ll > l2) ll = l2; 
	//	//kk  = rad1-0.5*l1/l2-sqrt(0.25*sqr(l1/l2)+rad0-rad1*l1/l2); if (rad >= rad1) ll *= (rad1-kk)/(rad-kk); 
	//	//kk  = l1+l2*(rad1-rad0)/4.; if (rad0 < rad && rad < rad1) ll = (kk-l2/(rad1-rad0)*sqr(rad-0.5*(rad1+rad0)))/rad; 
	//	
	//	sm->set_fasa_hmg(nju1, nju2, G1, G2, \D11 = G1/sqr(ll), G2*100.);
	//	el->set_fasa_hmg(nju1, nju2, G1, G2);

	//	KH = sm->TakeEshelby_volm_two (c0);
	//	GH = sm->TakeEshelby_shear_two(c0);

	//	K0 = el->TakeEshelby_volm_two (c0);
	//	G0 = el->TakeEshelby_shear_two(c0);

	//	EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
	//	E0 = 9.*K0*G0/(3.*K0+G0);

	//	nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	//fprintf(TST, " l1/rad = %g, rad = %g, KH = %g, GH = %g, EH = %g, E0 = %g, E_max = %g, nuH = %g\n", ll, rad, KH, GH, EH, E0, E_max, nuH);
	//	fprintf(TST, " %g, %g, %g, %g, %g, %g, %g\n", ll, rad, KH, GH, EH, E0, ll*rad);
	//}
	//fclose (TST);

/////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\E3\EB\EE\EC\E5\F0\E0\F2\E0 \EF\EE \EF\EE\F0\E8\F1\F2\EE\F1\F2\E8;
	//FILE * TST = fopen("Alumo3D_eps.dat", "w");
	//for (int j = 0; j <= 0; j += 1) {
	//	ff = eps*0.01;
	//	el->set_fasa_hmg(nju1, nju2, G1, 0.);

	//	K0 = el->TakeEshelby_volm_two (ff);
	//	G0 = el->TakeEshelby_shear_two(ff);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, " l1 = %g, l2 = %g, c0 = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", l1, l2, ff, K0, G0, E0, nu0);
	//}
	//fclose (TST);

///////////////////////////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\EB\FE\EC\EE\EA\EE\EC\EF\EE\E7\E8\F2\E0 (\F7\E5\F2\FB\F0\E5\F5\F4\E0\E7\ED\E0\FF \EC\EE\E4\E5\EB\FC, \EF\F0\E5\E4\E5\EB\FC\ED\FB\E9 \F1\EB\EE\E9);
	//FILE * TST = fopen("Alumo3D_limit.dat", "w");
	//for (int j = 1; j <= 200; j += 1) {
	//	ff = j*.00001; ll = pow(M_PI/(6.*ff), 1./3.)-1.;
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);

	//	//K0 = el->TakeEshelby_volm_two (ff);
	//	//G0 = el->TakeEshelby_shear_two(ff);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, " rad = %g, l1/rad = %g, c0 = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", l1/ll, ll, ff, K0, G0, E0, nu0);
	//}
	//fclose (TST);

	delete sm;
	delete el;
}
#endif
#ifdef ALUMO_COMPOSITES_EXAMPLES
{
//////////////////////////
//...model initialization;
	CDraft<double> * el = CreateDraft(LAME3D_DRAFT,  8);
/////////////////////////////////////////////////////////////////////////
////...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - \EC\E0\F2\F0\E8\F6\E0 \EF\EE\F0\E8\F1\F2\FB\E9 Al;
//	double nju1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
//			 nju3 = 0.30, //...\EC\E5\E6\F4\E0\E7\ED\FB\E9 \F1\EB\EE\E9;
//			 //E1   = 70.0, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \F1\EF\EB\EE\F8\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
//			 E1   = 18.0, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\F0\E8\F1\F2\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
//			 E3   = 57.5, //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF (GPa);
//			 G1   = E1/(1.+nju1)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\FF\E3\EA\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa);
//			 G3   = E3/(1.+nju3)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF (GPa);
//			 l1	= 0.200, //...\F0\E0\E7\EC\E5\F0 \EC\E5\E6\F4\E0\E7\ED\EE\E3\EE \F1\EB\EE\FF (\EC\EA\EC);
//			 eps	= 12.0,   //...\EF\EE\F0\E8\F1\F2\EE\F1\F2\FC (%);
//			 rad_str	= 3.5; //...\F0\E0\E7\EC\E5\F0 \E7\E5\F0\ED\E0 \E2 \F1\F2\F0\F3\EA\F2\F3\F0\E5 (\EC\EA\EC);
/////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \E4\E8\F1\EF\E5\F0\F1\ED\FB\EC\E8 \F7\E0\F1\F2\E8\F6\E0\EC\E8 - AL2O3;
	double nju2 = 0.20, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 E2   = 380., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa);
			 G2   = E2/(1.+nju2)*.5,  //...\EC\EE\E4\F3\EB\FC \F1\E4\E2\E8\E3\E0 \E4\E8\F1\EF\E5\F0\F1\ED\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa);
			 rad = 0.015,  //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \ED\E0\ED\EE\E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
			 c0  = 0.001,  //...\EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
			 G0, K0, E0, nu0, ff, ff_l, ll, kk;

//////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \EC\E0\F2\F0\E8\F6\FB \EF\EE \EF\EE\F0\E8\F1\F2\EE\F1\F2\E8;
	//FILE * TST = fopen("Alumo3D_eps.dat", "w");
	//for (int j = 0; j <= 0; j += 1) {
	//	ff = eps*0.01;
	//	el->set_fasa_hmg(nju1, nju2, G1, 0.);

	//	K0 = el->TakeEshelby_volm_two (ff);
	//	G0 = el->TakeEshelby_shear_two(ff);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, "eps = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", eps, K0, G0, E0, nu0);
	//}
	//fclose (TST);

//////////////////////////////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\EB\FE\EC\EE\EA\EE\EC\EF\EE\E7\E8\F2\E0 (\F7\E5\F2\FB\F0\E5\F5\F4\E0\E7\ED\E0\FF \EC\EE\E4\E5\EB\FC, \F4\E8\EA\F1\E8\F0\EE\E2\E0\ED\ED\FB\E9 \F1\EB\EE\E9);
	//FILE * TST = fopen("Alumo3D_layer.dat", "w");
	//for (int j = 0; j <= 5000; j += 1) {
	//	rad = j*0.001; kk = (ff = pow(1./c0, 1./3.)-1.)*rad/l1; if (kk > 1.) ll = l1/rad; else ll = ff; 
	//	//ll = ff*(1.-kk*(1.-2.*kk/3.))/(1.-kk*(1.-kk)); if (kk >= 0.001) ll = (l1/rad)*(1.-exp(-2.*kk))/(1.+exp(-2.*kk));
	//	ff_l = c0*(sqr(1.+ll)*(1.+ll)-1.);

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (c0, ff_l);
	//	G0 = el->TakeEshelby_shear(c0, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	//fprintf(TST, " rad = %g, l1 = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", rad, ll*rad, K0, G0, E0, nu0);
	//	fprintf(TST, " %g, %g, %g, %g, %g\n", rad, ll*rad, K0, G0, E0);
	//}
	//fclose (TST);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8 - \F0\E0\F1\F7\E5\F2 \E0\EB\FE\EC\EE\EA\EE\EC\EF\EE\E7\E8\F2\E0 (\F7\E5\F2\FB\F0\E5\F5\F4\E0\E7\ED\E0\FF \EC\EE\E4\E5\EB\FC, \EB\E8\ED\E5\E9\ED\FB\E9 \F0\EE\F1\F2 \F0\E0\E4\E8\F3\F1\E0 \EE\F2 \EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\E8);
	FILE * TST = fopen("Alumo3D_layer.dat", "w");
	for (int j = 1; j <= 3500; j += 1) {
		ff = j*.00001; kk = pow(6.e2, 1./3.)-1.;	ll = kk/sqrt(1.+sqr(0.3*ff/c0)); 
		if (ll > (kk = pow(1./ff, 1./3.)-1.)) ll = kk; rad = l1/ll;
		ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

		el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

		K0 = el->TakeEshelby_volm (ff, ff_l);
		G0 = el->TakeEshelby_shear(ff, ff_l);

		E0 = 9.*K0*G0/(3.*K0+G0);
		nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

		//fprintf(TST, " c0 = %g, rad = %g, l1/rad = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", ff*100, rad, ll, K0, G0, E0, nu0);
		fprintf(TST, " %g, %g, %g, %g, %g, %g\n", ff*100, rad, ll, K0, G0, E0);
	}
	fclose (TST);

	delete el;
}
#endif
#ifdef MINDL2D_CALCULATIONS
{
	char * name_ini = "./Models_inp/Box2D_circle/Box2D_circle_", name[2000];
	extern int gradient_model; gradient_model = 0;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(MINDL2D_DRAFT, 8);
	sm->set_mpls(PackInts(9, 9)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(16, 8)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);
	sm->set_lagrange(1e5);
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);

/////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \ED\E8\F2\E5\E2\E8\E4\FB\EC\E8 \EA\F0\E8\F1\F2\E0\EB\EB\E0\EC\E8 - \C2\CF\CC2;
	//double nju1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
	//		 //E1   = 210., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 20\D1;
	//		 //E1   = 150., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 600\D1;
	//		 E1   = 30.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 1400/1300\D1;
	//		 AA	= E1*.0,			 //...adhegion parameter;
	//		 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
	//		 l1	= 15.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 20\D1;
	//		 //l1	= 20.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 600\D1;
   //  	 //l1	= 25.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 1400/1300\D1;
	//		 l1_dop = 0.; //...interphase layer_dop;
////////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \ED\E8\F2\E5\E2\E8\E4\FB\EC\E8 \EA\F0\E8\F1\F2\E0\EB\EB\E0\EC\E8 - \C2\CA\CD\C0-1\D3;
	double nju1 = 0.33, //...\EF\EE\EB\E8\EC\E5\F0\ED\E0\FF \EC\E0\F2\F0\E8\F6\E0;
			 //E1   = 150., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 20\D1;
			 //E1   = 135., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 600\D1;
			 E1   = 40.,  //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \EF\EE\EB\E8\EC\E5\F0\ED\EE\E9 \EC\E0\F2\F0\E8\F6\FB (GPa), \D2 = 1400/1300\D1;
			 AA	= E1*.0,			 //...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 15.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 20\D1;
			 //l1	= 20.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 600\D1;
			 //l1	= 25.,  //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \EC\E0\F2\F0\E8\F6\FB (\EC\EA\EC), \D2 = 1400/1300\D1;
			 l1_dop = 0.; //...interphase layer_dop;
////////////////////////////////////////////////////////
//...\E4\E0\ED\ED\FB\E5 \E4\EB\FF \F0\E0\F1\F7\E5\F2\EE\E2 \F1 \ED\E8\F2\E5\E2\E8\E4\FB\EC\E8 \EA\F0\E8\F1\F2\E0\EB\EB\E0\EC\E8 AL2O3;
	double nju2 = 0.16, //...\E6\E5\F1\F2\EA\EE\E5 \E2\EA\EB\FE\F7\E5\ED\E8\E5;  
			 //E2   = 420., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa), \D2 = 20/600\D1;
			 E2   = 380., //...\EC\EE\E4\F3\EB\FC \DE\ED\E3\E0 \E6\E5\F1\F2\EA\EE\E3\EE \E2\EA\EB\FE\F7\E5\ED\E8\FF (GPa), \D2 = 1400/1300\D1;
			 l2	= 0.05, //...\EC\E0\F1\F8\F2\E0\E1\ED\FB\E9 \EF\E0\F0\E0\EC\E5\F2\F0 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC);
			 l2_dop	= 0.,//...interphase layer_dop;
			 rad = 0.5,   //...\F5\E0\F0\E0\EA\F2\E5\F0\ED\FB\E9 \F0\E0\E4\E8\F3\F1 \E2\EA\EB\FE\F7\E5\ED\E8\E9 (\EC\EA\EC); 
			 c0  = 0.45,  //...\EF\F0\E5\E4\E5\EB\FC\ED\E0\FF \EA\EE\ED\F6\E5\ED\F2\F0\E0\F6\E8\FF \E2\EA\EB\FE\F7\E5\ED\E8\E9; 
			 G1, G2, KH, GH, EH, nH, KM = E1/(1.-2.*nju1)/3., GM = E1/(1.+nju1)*.5, EM = E1, nM = nju1;
	sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, l1, l1_dop = l1_dop/sqrt(1.-2.*nju1), l2, l2_dop = l2_dop/sqrt(1.-2.*nju2), AA, BB);

///////////////////////////////  
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("mindl2D_homog.dat", "a");
	for (int jj = 30; jj <= 45; jj += 5) {
		double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
		sprintf(name, "%s%i%s", name_ini, jj, "_M208.inp"); 

///////////////////////////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\F5 \F3\F1\EB\EE\E2\E8\E9 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
		int id_reading = 0, i, j, l;
		if (sm) {
			sprintf(buf, "Loading model from file '%s'", name);
			Message(" ");
			Message(buf);
			Message("Reading data file ...");

			sm->stru.nodes_in(name);
			sm->bar_condit_in(name);
			sm->LinkUniStruct();
			sm->SetBUniStruct(POLY_BLOCK);

			if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
			for (j = 0; j < sm->id_prop[0]; j++)
			if (sm->id_prop[j*2+2] == BSOURCE_BND) {
				X0		= sm->pp_cond[j*6]; 
				Y0		= sm->pp_cond[j*6+1];
				ell_X = sm->pp_cond[j*6+2];
				ell_Y = sm->pp_cond[j*6+3];
				rot_Z = sm->pp_cond[j*6+4];
				id_reading = 1;
				break;
			}
			Message("Finish!");
		}
		double par[6];	sm->SetGeomBounding(par);
		if (! id_reading) {
			X0 = (par[0]+par[1])*.5;
			Y0 = (par[2]+par[3])*.5;
			ell_X = 0.15;
			ell_Y = 0.15;
			rot_Z = 0.;
		}
		if (ell_X != 0. && ell_Y != 0.) {
			CCells * ce = new(CCells);
			ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
			ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
			ce->mp[1] = X0;
			ce->mp[2] = Y0;
			ce->mp[4] = rot_Z/180.*M_PI;
			ce->mp[7] = ell_X;
			ce->mp[8] = ell_Y;
			ce->mp[l] = (CMap)NULL_CELL;
			sm->bar = new(CCells);
			sm->bar->bar_add(ce);
		}

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}

//////////////////
//..visualization;
		{	double K[17], ku1, lm1, mu1, ku2, lm2, mu2, Ez, Kxy, Gxy, Gxz, nxz, ff_vol; memset(K, 0, 17*sizeof(double));
			sm->GetRigidy(K);

/////////////////////
//...\EE\E1\FA\E5\EC\ED\FB\E9 \EC\EE\E4\F3\EB\FC;
			ff_vol = K[15];
			//ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

///////////////////////
//...\EC\E0\F2\F0\E8\F6\E0 \E6\E5\F1\F2\EA\EE\F1\F2\E8;
			ku1 = K[0];
			lm1 = K[2];
			mu1 = K[7];
			ku2 = K[14]*G1*(1.-nju1)/(.5-nju1)+K[15]*G2*(1.-nju2)/(.5-nju2)+
					(G2*nju2/(.5-nju2)-G1*nju1/(.5-nju1))/(G2/(1.-2.*nju2)-G1/(1.-2.*nju1))*
					(K[12]-K[14]*G1*nju1/(.5-nju1)-K[15]*G2*nju2/(.5-nju2));
			lm2 = K[13];
			mu2 = K[14]*G1+K[15]*G2;

///////////////////////////
//...\F2\E5\F5\ED\E8\F7\E5\F1\EA\E8\E5 \EA\EE\ED\F1\F2\E0\ED\F2\FB;
  			nxz = lm2/(ku1+lm1);
			Kxy = 0.5*(ku1+lm1);	
			Gxy = 0.5*(ku1-lm1);	
			Gxz = mu2;	
			Ez  = ku2-2.*lm2*nxz;

///////////////////////////////////////////////////////////////////
//...\F0\E5\E7\F3\EB\FC\F2\E0\F2 \EF\F0\EE\F1\F2\F0\E0\ED\F1\F2\E2\E5\ED\ED\EE\E3\EE \EE\F1\F0\E5\E4\ED\E5\ED\E8\FF \E2\EE\EB\EE\EA\EE\ED \EF\EE \CA\F0\E8\F1\F2\E5\ED\F1\E5\ED\F3;
			KH = (Ez+4.*sqr(1.+nxz)*Kxy)/9.;
			GH = (Ez+sqr(1.-2.*nxz)*Kxy+6.*(Gxy+Gxz))/15.;
			EH = 9.*KH*GH/(3.*KH+GH);
			nH = (3.*KH-2.*GH)/(3.*KH+GH)*.5;

			//nH = 1./(2.*(Ez+Gxy+Gxz)+(8.*sqr(nxz)+12.*nxz+7.)*Kxy);
			//EH = 5.*GH*nH*(Ez+4.*sqr(1.+nxz)*Kxy);
			//nH = .5*nH*(Ez+2.*(2.*sqr(nxz)+8.*nxz+3.)*Kxy-4.*(Gxy+Gxz));

			fprintf(TST, "ff_vol = %g  KH = %g  KM = %g  GH = %g  GM = %g  EH = %g  EM = %g  nH = %g  nM = %g  Ez = %g  Kxy = %g  Gxy = %g  Gxz = %g  nxz = %g  mu1 = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
							  ff_vol, KH, KM, GH, GM, EH, EM, nH, nM, Ez, Kxy, Gxy, Gxz, nxz, mu1, ell_X, ell_Y, rot_Z, E2, E1, nju2, nju1);

			int id_visual = 0;
			if (id_visual) {//..visualization;
				CGrid * nd = CreateNodes();
				sm->BlockActivate(NULL_STATE);

				int NX = 100, NY = 100;
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(par[0]+.5*i/NX*(par[1]-par[0]));
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(par[2]+.5*j/NY*(par[3]-par[2]));

				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
					sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
					nd->hit[i+j*nd->N] = hit;
				}
				system("del *.grd");
				sm->GetSurferFormat("bb",	 nd,					ERR_VALUE);
				sm->GetSurferFormat("rr",	 nd,				 DISPL_VALUE);
				sm->GetSurferFormat("tf_x", nd,			 STRESS_X_VALUE);
				sm->GetSurferFormat("tt_x", nd, STRESS_X_CLASSIC_VALUE);
				
				delete nd;
			}
		}
	}
	fclose (TST);
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT_ESHELBY
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(HEAT3D_DRAFT);
	double K1 = 1.7,	//...\EE\EA\F1\E8\E4 \F6\E8\F0\EA\EE\ED\E8\FF (matrtix);
			 K2 = 30.,	//...\EA\EE\F0\F3\ED\E4 (inclusion);
			 K3 = 3.,	//...\EF\F0\EE\EC\E5\E6\F3\F2\EE\F7\ED\FB\E9 \F1\EB\EE\E9;
			 c1 = 0.70, //...interphase layer;
			 c0 = 0.20, ll = 0.7, R1 = 1.5, KH, KH_cl, KH2; //...volume fraction;
	sm->set_fasa_hmg(K1, K2, K3);

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	FILE * TST = fopen("heat3D_homog.dat", "w");
	for (int j = 200; j <= 1000; j += 10) {
		c0 = j*.001;
		sm->set_fasa_hmg(R1, R1*pow(c0, -1./3.), K1, K2, K3, 1./sqr(ll));
		
		KH = ((CHeat3D *)sm)->TakeEshelby_grad(c0);
		KH_cl = sm->TakeEshelby_two(c0);

		fprintf(TST, " c0 = %g, \F11 = %g, KH = %g\n", c0, c1, KH);
	}
	fclose (TST);
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT_NONLINEAR_LAYER
{
	char * name = "heat1D_nonlinear_layer.dat";
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraft(HEAT2D_DRAFT);
	int N1 = 20, N2 = 10, N_cells = 5, NN = (N1+N2)*N_cells, m = 1000, MM = 30000, M0 = MM/m, k, j, l;
	double x = 0., h = 0.05, t = 0., dt = 0.001, alpha = dt/sqr(h), 
			*T = (double *)new_struct((NN+1)*sizeof(double)), ** out = NULL, 
			//T0 = 273, TS = 300;
			T0 =  15, TS =  45;
			//T0 = 120, TS = 170;
	set_matrix(out, NN+2, M0+1);

////////////////////////////////////////////////////
//...\ED\E0\F7\E0\EB\FC\ED\FB\E5 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\E5 \E4\E0\ED\ED\FB\E5, \F0\E0\F1\EF\E5\F7\E0\F2\EA\E0 \F1\E5\F2\EA\E8;
	for (T[0] = TS, k = 1; k <= NN; k++) T[k] = T0;

	for (l = 0, k = 0; k <= NN; k++, x += h) out[k][l] = x; 
	out[k][l] = h;

	for (l = 1, k = 0; k <= NN; k++) out[k][l] = T[k]; 
	out[k][l] = t;

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	for (j = 1; j < MM; j++) {
		//((CHeat2D *)sm)->TakeStabStep(T, NN, alpha); t += dt;
		((CHeat2D *)sm)->TakeStabStep_layer(T, N1, N2, N_cells, alpha); t += dt;
		if (!(j%m) && (++l) <= M0) {
			for (k = 0; k <= NN; k++) out[k][l] = T[k]; 
			out[k][l] = t;
		}
	}

////////////////////////////
//...\F0\E0\F1\EF\E5\F7\E0\F2\EA\E0 \F0\E5\E7\F3\EB\FC\F2\E0\F2\EE\E2;
	FILE *  TST = fopen(name, "w");
	fprintf(TST, "h = %g", out[NN+1][0]);
	for (j = 1; j <= M0; j++) fprintf(TST, ", t = %g", out[NN+1][j]);
	fprintf(TST, "\n");

	for (k = 0; k <= NN; k++) {
		fprintf(TST, "%g", out[k][0]);
		for (j = 1; j <= M0; j++) fprintf(TST, ", %g", out[k][j]);
		fprintf(TST, "\n");
	}
	fclose(TST);

	delete_struct(out);
	delete_struct(T);
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT_FIRST_MEMBER
{
	char * name = "./Parametric/Unit2d_1.nas";
	char * name_out = "heat1D_nonlinear_layer.dat";
//	char * name = "./Box2d_homog/heat_clayer488.nas";
//	char * name = "./Box2d_homog/heat_cyl_layer1148.nas";
//	char * name = "./Box2d_homog/heat_ell_layer1174.nas";
//	char * name = "./Box2d_homog/sph_025_16.nas";

	double L = 0.5, eps_in = 1e-2;
	int i, k, j, l; 

//////////////////////////
//...\E8\ED\E8\F6\E8\E0\EB\E8\E7\E0\F6\E8\FF \EC\EE\E4\E5\EB\E8;
	CDraft<double> * sm = CreateDraft(HEAT2D_DRAFT, 8);		
	sm->set_mpls(PackInts(13, 13)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(16, 8)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);			//...normalization coefficient;
	sm->set_lagrange(1e-4);		  //...Lagrange coefficient for energy;
	sm->solver.set_mode(/*PRINT_MODE | FULLY_MODE | MASKS_MODE | ACCUMULATION*/);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->change_solv(SPECIAL_SOLVING);
	double KK1 = 1.,		//...heat conduction (matrix);
			 KK2 = 413./150.,		//...heat conduction (inclusion);
			 KK3 = KK2,		//...heat conduction (intermediate);
			 R1 = 0.3,		//...inclusion geometry;
			 R2 = 0.3125;		//...intermediate geometry; 
	sm->set_fasa_hmg(R1, R2, KK1, KK2, KK3);

///////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);
		Message("Finish!");
	}

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		if (sm) delete sm;
		goto err;
	}

///////////////////
//..homogenization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
//////////////////
//..visualization;
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	sm->SetGeomBounding(par);
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			sm->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
			sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}
	//int N1 = 400, N2 = 200, N_cells = 10, NN = (N1+N2)*N_cells, m = 100000, MM = 3000000, M0 = MM/m, m_shift = 1;
	//double x = 0., h = 0.000002, t = 0., dt = 0.00000000002, alpha = dt/sqr(h), fnorm = 1e-6, t0 = 0.5e-4,
	int N1 = 400, N2 = 200, N_cells = 10, NN = (N1+N2)*N_cells, m = 1000000, MM = 25000000, M0 = MM/m, m_shift = 1;
	double x = 0., h = 0.000002, t = 0., dt = 0.00000002, alpha = dt/sqr(h), fnorm = 1e-3, t0 = 0.5,
	//int N1 = 400, N2 = 200, N_cells = 10, NN = (N1+N2)*N_cells, m = 100000, MM = 3000000, M0 = MM/m, m_shift = 1;
	//double x = 0., h = 0.000002, t = 0., dt = 0.00000002, alpha = dt/sqr(h), fnorm = 1e-3, t0 = 0.05,
			*T = (double *)new_struct((NN+1)*sizeof(double)), ** out = NULL, 
			//T0 =  15, TS =  45;
			T0 = 273, TS = 300;
			//T0 = 120, TS = 170; 
	set_matrix(out, NN+2, M0+1);

////////////////////////////////////////////////////
//...\ED\E0\F7\E0\EB\FC\ED\FB\E5 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\E5 \E4\E0\ED\ED\FB\E5, \F0\E0\F1\EF\E5\F7\E0\F2\EA\E0 \F1\E5\F2\EA\E8;
	for (T[0] = TS, k = 1; k <= NN; k++) T[k] = T0;

	for (l = 0, k = 0; k <= NN; k++, x += h) out[k][l] = x; 
	out[k][l] = h;

	for (l = 1, k = 0; k <= NN; k++) out[k][l] = T[k]; 
	out[k][l] = t;

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	for (j = 1; j < MM; j++) {
		((CHeat2D *)sm)->TakeStabStep(T, NN, alpha); t += dt;
		//((CHeat2D *)sm)->TakeStabStep_layer(T, N1, N2, N_cells, alpha); t += dt;
		if (!(j%m) && (++l) <= M0) {
			for (k = 0; k <= NN; k++) out[k][l] = T[k]; 
			out[k][l] = t;
		}
	}

////////////////////////////
//...\F0\E0\F1\EF\E5\F7\E0\F2\EA\E0 \F0\E5\E7\F3\EB\FC\F2\E0\F2\EE\E2;
	FILE *  TST = fopen(name_out, "w");
	fprintf(TST, "h = %g", out[NN+1][0]);
	for (j = 1; j <= M0; j++) fprintf(TST, ", t = %g", out[NN+1][j]);
	fprintf(TST, "\n");

	for (k = 0; k <= NN; k++) {
		fprintf(TST, "%g", out[k][0]);
		for (j = 1; j <= M0; j++) fprintf(TST, ", %g", out[k][j]);
		fprintf(TST, "\n");
	}
	fclose(TST);

//////////////////////////////////////////////////////////
//...\F0\E0\F1\F7\E5\F2 \F4\F3\ED\EA\F6\E8\E9 \E1\FB\F1\F2\F0\FB\F5 \EF\E5\F0\E5\EC\E5\ED\ED\FB\F5 (\E4\EB\FF \F0\E0\E7\ED\FB\F5 \FF\F7\E5\E5\EA);
	int nn = 7, mm = 3, n, ii = (int)(t0/dt)/m+2-m_shift, nn_fast = 40;
	CDraft<double> ** dr = (CDraft<double> **)new_struct(nn*sizeof(CDraft<double> *)*nn_fast);
	double * K1 = (double *)new_struct(nn*sizeof(double)*nn_fast), 
			 * K2 = (double *)new_struct(nn*sizeof(double)*nn_fast), eps = 1.6e-3; 
	for (n = 0; n < nn*nn_fast; n++) {
		dr[n] = CreateDraft(HEAT2D_DRAFT, 8);		
		dr[n]->set_mpls(PackInts(13, 13)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
		dr[n]->set_quad(PackInts(16, 8)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
		dr[n]->set_normaliz(0.92);			//...normalization coefficient;
		dr[n]->set_lagrange(1e-4);		  //...Lagrange coefficient for energy;
		dr[n]->solver.set_mode(/*PRINT_MODE | FULLY_MODE | MASKS_MODE | ACCUMULATION*/);
		dr[n]->solver.change_state(/*EXTERN_STATE*/);
		dr[n]->change_solv(SPECIAL_SOLVING);
///////////////////////////////////
//...\F5\E0\F0\E0\EA\F2\E5\F0\E8\F1\F2\E8\EA\E8 \EA\F0\E5\EC\ED\E8\FF \E8 \EC\E5\E4\E8;
		int n0 = 12, id_num; k = (int)((n+0.5)*eps/(h*nn_fast));
		double K_SC[] = {300.,2300.,5000.,3500.,1340.,410.,260.,150.,99.,62.,42.,31.},
				 K_CU[] = {16200.,24000.,10800.,2170.,560.,429.,413.,401.,393.,379.,366.,352.},
				 TH[] = {4.,10.,20.,30.,80.,150.,200.,300.,400.,600.,800.,1000.}, TT = out[k][ii];
		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K1[n] = K_SC[id_num];
		if (id_num > 0 && id_num  < n0) K1[n] = K_SC[id_num-1]+(K_SC[id_num]-K_SC[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == n0) K1[n] = K_SC[id_num-1];

		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K2[n] = K_CU[id_num];
		if (id_num > 0 && id_num  < n0) K2[n] = K_CU[id_num-1]+(K_CU[id_num]-K_CU[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == nn) K2[n] = K_CU[id_num-1];

///////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
		dr[n]->stru.nodes_in(name);
		dr[n]->bar_condit_in(name);
		dr[n]->LinkUniStruct();
		dr[n]->SetBUniStruct(CLAYER_BLOCK);

////////////////////////////
//...solving of the problem;
		dr[n]->set_fasa_hmg(0.3, 0.3125, 1., K2[n]/K1[n], K2[n]/K1[n]);
		if (dr[n]->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample counting...");
			if (dr[n]) delete dr[n];
			goto err;
		}
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	dr[n]->SetGeomBounding(par);
			dr[n]->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			dr[n]->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
			dr[n]->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}

////////////////////////////
//..\EF\E5\F0\E2\FB\E9 \F7\EB\E5\ED \E0\F1\E8\EC\EF\F2\EE\F2\E8\EA\E8;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		double par[6];	dr[0]->SetGeomBounding(par);
		for (n = 0; n < nn*nn_fast; n++) dr[n]->BlockActivate(NULL_STATE);

		int NX = 100, NY = 100;
		for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
		for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

		nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

		FILE * SURF = fopen("rr.grd", "w+b"), 
			  * SURF1 = fopen("pp.grd", "w+b"); 
		size_t res;

	  if (nd && nd->N > 0 && nd->N1 > 0 && SURF && SURF1) {
			short int i0 = (short int)nd->N*nn, 
						 j0 = (short int)nd->N1*mm;
			double * out_F = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), 
					 * out_F1 = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), X, Y, Z, d, dd, 
						min1F = 0., max1F = 1., 
						min2F = 0., max2F = 1.;
			int hit;
			if (SURF) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF);
				res = fwrite(& i0,   sizeof(short int), 1, SURF); res = fwrite(& j0,         sizeof(short int), 1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF);
				res = fwrite(& min1F, sizeof(double), 1, SURF); res = fwrite(& max1F,        sizeof(double),  1, SURF);
			}
			if (SURF1) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF1);
				res = fwrite(& i0,   sizeof(short int), 1, SURF1); res = fwrite(& j0,         sizeof(short int), 1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF1);
				res = fwrite(& min2F, sizeof(double), 1, SURF1); res = fwrite(& max2F,        sizeof(double),  1, SURF1);
			}
			min1F = min2F = MAX_HIT; 
			max1F = max2F = MIN_HIT;
			for (l = 0; l < mm;		l++)
			for (j = 0; j < nd->N1; j++)
			for (n = 0; n < nn;		n++)
			for (i = 0; i < nd->N;  i++) {
				X = nd->X[i];
				Y = nd->Y[j];
				Z = 0.;

				float ff = NOT_HIT; 
				if (nd->hit) hit = nd->hit[i+j*nd->N];
				if (hit != -1)  {
/////////////////////////////////////////////////////////
//..\E2\FB\F7\E8\F1\EB\FF\E5\EC \E8\F1\F2\E8\ED\ED\FB\E5 \EA\EE\EE\F0\E4\E8\ED\E0\F2\FB, \F4\F3\ED\EA\F6\E8\FE \E8 \EF\F0\EE\E8\E7\E2\EE\E4\ED\F3\FE;
					k = (int)(x = (X+n)*eps/h);
					d = (x-k)*(out[k+1][ii]-out[k][ii])+out[k][ii];
					dd = (out[k+1][ii]-out[k][ii])/h;
					int n_fast = min(n*nn_fast+(int)(X*nn_fast), nn*nn_fast-1);

					if (SURF) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F, hit, HEAT_VALUE);
						out_F[0] = d+out_F[0]*dd*eps;
						
						res = fwrite(& (ff = (float)out_F[0]), sizeof(float), 1, SURF);
						if (min1F > out_F[0]) min1F = out_F[0];
						if (max1F < out_F[0]) max1F = out_F[0];
					}
					if (SURF1) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F1, hit, FLUX_COMPOS_VALUE);
						out_F1[0] = out_F1[0]*dd*K1[n_fast]*fnorm;

						res = fwrite(& (ff = (float)out_F1[0]), sizeof(float), 1, SURF1);
						if (min2F > out_F1[0]) min2F = out_F1[0];
						if (max2F < out_F1[0]) max2F = out_F1[0];
					}
				}
				else {
					if (SURF ) res = fwrite(& ff, sizeof(float), 1, SURF);
					if (SURF1) res = fwrite(& ff, sizeof(float), 1, SURF1);
				}
			}
			delete_struct(out_F);
			delete_struct(out_F1);

//////////////////////////////////////////////////////////////
//...\EF\E5\F0\E5\E7\E0\EF\E8\F1\FC \EC\E0\EA\F1\E8\EC\E0\EB\FC\ED\EE\E3\EE \E8 \EC\E8\ED\E8\EC\E0\EB\FC\ED\EE\E3\EE \E7\ED\E0\F7\E5\ED\E8\FF \F4\F3\ED\EA\F6\E8\E8;
			if (SURF) {
				res = fseek(SURF, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min1F, sizeof(double), 1, SURF);
				res = fwrite(& max1F, sizeof(double), 1, SURF);
				res = fseek(SURF, 0L, SEEK_END);
			}
			if (SURF1) {
				res = fseek(SURF1, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min2F, sizeof(double), 1, SURF1);
				res = fwrite(& max2F, sizeof(double), 1, SURF1);
				res = fseek(SURF1, 0L, SEEK_END);
			}
		}
		if (SURF ) fclose(SURF);
		if (SURF1) fclose(SURF1);
		delete nd;
	}
	delete_struct(out);
	delete_struct(T);
	delete sm;
	for (n = 0; n < nn; n++) delete dr[n];
	delete_struct(dr);
	delete_struct(K1);
	delete_struct(K2);
}
#endif
#ifdef TEST_DRAFT_HEAT_FIRST_MEMBER_NONLINEAR_LAYER
{
	char * name = "./Parametric/Unit2d_1.nas";
	char * name_out = "heat1D_nonlinear_layer.dat";

	double L = 0.5, eps_in = 1e-2;
	int i, k, j, l; 

//////////////////////////
//...\E8\ED\E8\F6\E8\E0\EB\E8\E7\E0\F6\E8\FF \EC\EE\E4\E5\EB\E8;
	CDraft<double> * sm = CreateDraft(HEAT2D_DRAFT, 8);		
	sm->set_mpls(PackInts(1, 1)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
	sm->set_quad(PackInts(1, 1)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
	sm->set_normaliz(0.92);			//...normalization coefficient;
	double KK1 = 1.,				  //...heat conduction (matrix);
			 KK2 = 413./150.,		 //...heat conduction (inclusion);
			 KK3 = KK2,			   //...heat conduction (intermediate);
			 R1 = 0.3,			  //...inclusion geometry;
			 R2 = 0.3125;		 //...intermediate geometry; 
	sm->set_fasa_hmg(R1, R2, KK1, KK2, KK3);
	sm->change_solv(SPECIAL_SOLVING);

///////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);
		Message("Finish!");
	}

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample counting...");
		if (sm) delete sm;
		goto err;
	}

///////////////////
//..homogenization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
//////////////////
//..visualization;
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	sm->SetGeomBounding(par);
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			sm->GetSurferFormat("rr", nd, HEAT_ANALYT_VALUE, 0);
			sm->GetSurferFormat("pp", nd, FLUX_ANALYT_VALUE, 0);

			delete nd;
		}
	}
	int N1 = 30, N2 = 50, N_cells = 10, NN = (N1+N2)*(N_cells+1), m = 10000, MM = 3000000, M0 = MM/m, m_shift = 1;
	double x = 0., h = 0.00002, t = 0., dt = 0.0000002, alpha = dt/sqr(h), fnorm = 1e-3, t0 = 0.5,
			*T = (double *)new_struct((NN+1)*sizeof(double)), ** out = NULL, 
			T0 = 273, TS = 300;
	set_matrix(out, NN+2, M0+1);

////////////////////////////////////////////////////
//...\ED\E0\F7\E0\EB\FC\ED\FB\E5 \E8 \E3\F0\E0\ED\E8\F7\ED\FB\E5 \E4\E0\ED\ED\FB\E5, \F0\E0\F1\EF\E5\F7\E0\F2\EA\E0 \F1\E5\F2\EA\E8;
	for (T[0] = TS, k = 1; k <= NN; k++) T[k] = T0;

	for (l = 0, k = 0; k <= NN; k++, x += h) out[k][l] = x; 
	out[k][l] = h;

	for (l = 1, k = 0; k <= NN; k++) out[k][l] = T[k]; 
	out[k][l] = t;

///////////////////////////////
//...\F6\E8\EA\EB \EF\EE \EF\E0\F0\E0\EC\E5\F2\F0\E0\EC \E7\E0\E4\E0\F7\E8;
	for (j = 1; j < MM; j++) {
		//((CHeat2D *)sm)->TakeStabStep(T, NN, alpha); t += dt;
		((CHeat2D *)sm)->TakeStabStep_layer(T, N1, N2, N_cells, alpha); t += dt;
		if (!(j%m) && (++l) <= M0) {
			for (k = 0; k <= NN; k++) out[k][l] = T[k]; 
			out[k][l] = t;
		}
	}

////////////////////////////
//...\F0\E0\F1\EF\E5\F7\E0\F2\EA\E0 \F0\E5\E7\F3\EB\FC\F2\E0\F2\EE\E2;
	FILE *  TST = fopen(name_out, "w");
	fprintf(TST, "h = %g", out[NN+1][0]);
	for (j = 1; j <= M0; j++) fprintf(TST, ", t = %g", out[NN+1][j]);
	fprintf(TST, "\n");

	for (k = 0; k <= NN; k++) {
		fprintf(TST, "%g", out[k][0]);
		for (j = 1; j <= M0; j++) fprintf(TST, ", %g", out[k][j]);
		fprintf(TST, "\n");
	}
	fclose(TST);

//////////////////////////////////////////////////////////
//...\F0\E0\F1\F7\E5\F2 \F4\F3\ED\EA\F6\E8\E9 \E1\FB\F1\F2\F0\FB\F5 \EF\E5\F0\E5\EC\E5\ED\ED\FB\F5 (\E4\EB\FF \F0\E0\E7\ED\FB\F5 \FF\F7\E5\E5\EA);
	int nn = 7, mm = 3, n, ii = (int)(t0/dt)/m+2-m_shift, nn_fast = 40;
	CDraft<double> ** dr = (CDraft<double> **)new_struct(nn*sizeof(CDraft<double> *)*nn_fast);
	double * K1 = (double *)new_struct(nn*sizeof(double)*nn_fast), 
			 * K2 = (double *)new_struct(nn*sizeof(double)*nn_fast), eps = 1.6e-3; 
	for (n = 0; n < nn*nn_fast; n++) {
		dr[n] = CreateDraft(HEAT2D_DRAFT, 8);		
		dr[n]->set_mpls(PackInts(13, 13)); //...\F1\F2\E5\EF\E5\ED\FC \EC\F3\EB\FC\F2\E8\EF\EE\EB\E5\E9;
		dr[n]->set_quad(PackInts(16, 8)); //...\F1\F2\E5\EF\E5\ED\FC \EA\E2\E0\E4\F0\E0\F2\F3\F0\FB;
		dr[n]->set_normaliz(0.92);			//...normalization coefficient;
		dr[n]->set_lagrange(1e-4);		  //...Lagrange coefficient for energy;
		dr[n]->solver.set_mode(/*PRINT_MODE | FULLY_MODE | MASKS_MODE | ACCUMULATION*/);
		dr[n]->solver.change_state(/*EXTERN_STATE*/);
		dr[n]->change_solv(SPECIAL_SOLVING);
///////////////////////////////////
//...\F5\E0\F0\E0\EA\F2\E5\F0\E8\F1\F2\E8\EA\E8 \EA\F0\E5\EC\ED\E8\FF \E8 \EC\E5\E4\E8;
		int n0 = 12, id_num; k = (int)((n+0.5)*eps/(h*nn_fast));
		double K_SC[] = {300.,2300.,5000.,3500.,1340.,410.,260.,150.,99.,62.,42.,31.},
				 K_CU[] = {16200.,24000.,10800.,2170.,560.,429.,413.,401.,393.,379.,366.,352.},
				 TH[] = {4.,10.,20.,30.,80.,150.,200.,300.,400.,600.,800.,1000.}, TT = out[k][ii];
		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K1[n] = K_SC[id_num];
		if (id_num > 0 && id_num  < n0) K1[n] = K_SC[id_num-1]+(K_SC[id_num]-K_SC[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == n0) K1[n] = K_SC[id_num-1];

		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K2[n] = K_CU[id_num];
		if (id_num > 0 && id_num  < n0) K2[n] = K_CU[id_num-1]+(K_CU[id_num]-K_CU[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == nn) K2[n] = K_CU[id_num-1];

///////////////////////////////////
//...\F7\F2\E5\ED\E8\E5 \EC\EE\E4\E5\EB\E8 \E8\E7 \F4\E0\E9\EB\E0 \E4\E0\ED\ED\FB\F5;
		dr[n]->stru.nodes_in(name);
		dr[n]->bar_condit_in(name);
		dr[n]->LinkUniStruct();
		dr[n]->SetBUniStruct(CLAYER_BLOCK);

////////////////////////////
//...solving of the problem;
		dr[n]->set_fasa_hmg(0.3, 0.3125, 1., K2[n]/K1[n], K2[n]/K1[n]);
		if (dr[n]->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample counting...");
			if (dr[n]) delete dr[n];
			goto err;
		}
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	dr[n]->SetGeomBounding(par);
			dr[n]->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			dr[n]->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
			dr[n]->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}

/////////////////////////////////////////////
//..\EF\E5\F0\E2\FB\E9 \F7\EB\E5\ED \E0\F1\E8\EC\EF\F2\EE\F2\E8\EA\E8 \E2 \F4\EE\F0\EC\E0\F2\E5 Surfer;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		double par[6];	dr[0]->SetGeomBounding(par);
		for (n = 0; n < nn*nn_fast; n++) dr[n]->BlockActivate(NULL_STATE);

		int NX = 100, NY = 100;
		for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
		for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

		nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

		FILE * SURF = fopen("rr.grd", "w+b"), 
			  * SURF1 = fopen("pp.grd", "w+b"); 
		size_t res;

	  if (nd && nd->N > 0 && nd->N1 > 0 && SURF && SURF1) {
			short int i0 = (short int)nd->N*nn, 
						 j0 = (short int)nd->N1*mm;
			double * out_F = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), 
					 * out_F1 = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), X, Y, Z, d, dd, 
						min1F = 0., max1F = 1., 
						min2F = 0., max2F = 1.;
			int hit;
			if (SURF) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF);
				res = fwrite(& i0,   sizeof(short int), 1, SURF); res = fwrite(& j0,         sizeof(short int), 1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF);
				res = fwrite(& min1F, sizeof(double), 1, SURF); res = fwrite(& max1F,        sizeof(double),  1, SURF);
			}
			if (SURF1) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF1);
				res = fwrite(& i0,   sizeof(short int), 1, SURF1); res = fwrite(& j0,         sizeof(short int), 1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF1);
				res = fwrite(& min2F, sizeof(double), 1, SURF1); res = fwrite(& max2F,        sizeof(double),  1, SURF1);
			}
			min1F = min2F = MAX_HIT; 
			max1F = max2F = MIN_HIT;
			for (l = 0; l < mm;		l++)
			for (j = 0; j < nd->N1; j++)
			for (n = 0; n < nn;		n++)
			for (i = 0; i < nd->N;  i++) {
				X = nd->X[i];
				Y = nd->Y[j];
				Z = 0.;

				float ff = NOT_HIT; 
				if (nd->hit) hit = nd->hit[i+j*nd->N];
				if (hit != -1)  {
/////////////////////////////////////////////////////////
//..\E2\FB\F7\E8\F1\EB\FF\E5\EC \E8\F1\F2\E8\ED\ED\FB\E5 \EA\EE\EE\F0\E4\E8\ED\E0\F2\FB, \F4\F3\ED\EA\F6\E8\FE \E8 \EF\F0\EE\E8\E7\E2\EE\E4\ED\F3\FE;
					k = (int)(x = (X+n)*eps/h);
					d = (x-k)*(out[k+1][ii]-out[k][ii])+out[k][ii];
					dd = (out[k+1][ii]-out[k][ii])/h;
					int n_fast = min(n*nn_fast+(int)(X*nn_fast), nn*nn_fast-1);

					if (SURF) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F, hit, HEAT_ANALYT_VALUE);
						out_F[0] = d+out_F[0]*dd*eps;
						
						res = fwrite(& (ff = (float)out_F[0]), sizeof(float), 1, SURF);
						if (min1F > out_F[0]) min1F = out_F[0];
						if (max1F < out_F[0]) max1F = out_F[0];
					}
					if (SURF1) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F1, hit, FLUX_ANALYT_VALUE);
						out_F1[0] = out_F1[0]*dd*K1[n_fast]*fnorm;

						res = fwrite(& (ff = (float)out_F1[0]), sizeof(float), 1, SURF1);
						if (min2F > out_F1[0]) min2F = out_F1[0];
						if (max2F < out_F1[0]) max2F = out_F1[0];
					}
				}
				else {
					if (SURF ) res = fwrite(& ff, sizeof(float), 1, SURF);
					if (SURF1) res = fwrite(& ff, sizeof(float), 1, SURF1);
				}
			}
			delete_struct(out_F);
			delete_struct(out_F1);

//////////////////////////////////////////////////////////////
//...\EF\E5\F0\E5\E7\E0\EF\E8\F1\FC \EC\E0\EA\F1\E8\EC\E0\EB\FC\ED\EE\E3\EE \E8 \EC\E8\ED\E8\EC\E0\EB\FC\ED\EE\E3\EE \E7\ED\E0\F7\E5\ED\E8\FF \F4\F3\ED\EA\F6\E8\E8;
			if (SURF) {
				res = fseek(SURF, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min1F, sizeof(double), 1, SURF);
				res = fwrite(& max1F, sizeof(double), 1, SURF);
				res = fseek(SURF, 0L, SEEK_END);
			}
			if (SURF1) {
				res = fseek(SURF1, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min2F, sizeof(double), 1, SURF1);
				res = fwrite(& max2F, sizeof(double), 1, SURF1);
				res = fseek(SURF1, 0L, SEEK_END);
			}
		}
		if (SURF ) fclose(SURF);
		if (SURF1) fclose(SURF1);
		delete nd;
	}

///////////////////////////////////////////
//..\EF\E5\F0\E2\FB\E9 \F7\EB\E5\ED \E0\F1\E8\EC\EF\F2\EE\F2\E8\EA\E8 \E2 \F4\EE\F0\EC\E0\F2\E5 Exel;
	id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		double par[6];	dr[0]->SetGeomBounding(par);
		for (n = 0; n < nn*nn_fast; n++) dr[n]->BlockActivate(NULL_STATE);

		int NX = 40;
		for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
		nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

		FILE * EXEL = fopen("rr.dat", "w"); 
		size_t res;

	  if (nd && nd->N > 0 && EXEL) {
			double * out_F = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), X, Y = 0., Z = 0., d, dd;
			for (l = 0; l < mm;	  l++)
			for (n = 0; n < nn;	  n++)
			for (i = 0; i < nd->N; i++) {
				X = nd->X[i];

/////////////////////////////////////////////////////////
//..\E2\FB\F7\E8\F1\EB\FF\E5\EC \E8\F1\F2\E8\ED\ED\FB\E5 \EA\EE\EE\F0\E4\E8\ED\E0\F2\FB, \F4\F3\ED\EA\F6\E8\FE \E8 \EF\F0\EE\E8\E7\E2\EE\E4\ED\F3\FE;
				k = (int)(x = (X+n)*eps/h);
				d = (x-k)*(out[k+1][ii]-out[k][ii])+out[k][ii];
				dd = (out[k+1][ii]-out[k][ii])/h;
				int n_fast = min(n*nn_fast+(int)(X*nn_fast), nn*nn_fast-1);

				if (EXEL) {
					dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F, 0, HEAT_ANALYT_VALUE);
					out_F[0] = d+out_F[0]*dd*eps;

					fprintf(EXEL, "%g,   %g\n", x*h, out_F[0]);
				}
			}
			delete_struct(out_F);
		}
		if (EXEL) fclose(EXEL);
		delete nd;
	}
	delete_struct(out);
	delete_struct(T);
	delete sm;
	for (n = 0; n < nn; n++) delete dr[n];
	delete_struct(dr);
	delete_struct(K1);
	delete_struct(K2);
}
#endif
err:
	printf("\nFull time: %ld sec\n", sec = time(NULL)-start);
	printf("\nTEST >> Is the work finished? (Y/N) : "); //res = scanf("%s", buf);
	printf("\n");

#ifdef ___IGROUPS_NGROUPS___
	};
#endif
#ifdef ___MPI_INIT___
	MPI_Barrier (MPI_COMM_WORLD);
	MPI_Finalize();
#endif
	return 0;
}

